<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MindMap</title>
    <link rel='shortcut icon' href='data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIGZpbGw9IiMwMDAwMDAiIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgCgkgdmlld0JveD0iMCAwIDM0MS41OTQgMzQxLjU5NCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik0zMTEuMDQ5LDE2NC43NThjLTkuMjc1LDAtMTcuNDgxLDQuNjQ0LTIyLjQzMiwxMS43MjRsLTIwLjE3MS0zLjQ5NWMwLjAyNS0wLjc1OCwwLjA1OC0xLjUxNSwwLjA1OC0yLjI3OQoJYzAtOC45NTQtMS43NzYtMTcuNDk4LTQuOTczLTI1LjMxNmwzNC4xNjMtMjAuNjEyYzQuNTk3LDMuNTAxLDEwLjMyNyw1LjU4NCwxNi41MzgsNS41ODRjMTUuMDg3LDAsMjcuMzYxLTEyLjI3NCwyNy4zNjEtMjcuMzYxCgljMC0xNS4wODYtMTIuMjc0LTI3LjM1OS0yNy4zNjEtMjcuMzU5Yy0xNS4wODYsMC0yNy4zNTksMTIuMjczLTI3LjM1OSwyNy4zNTljMCwxLjYwMywwLjE0NiwzLjE3MSwwLjQxMiw0LjY5OWwtMzMuOTkzLDIwLjUwOQoJYy0xMC4zMTQtMTIuNTc0LTI1LjA5Ny0yMS4zNDUtNDEuODk5LTIzLjg2N1Y2Mi4zNzNjMTIuNTM3LTQuMTk0LDIxLjYwNC0xNi4wNCwyMS42MDQtMjkuOTcxYzAtMTcuNDI3LTE0LjE3OC0zMS42MDYtMzEuNjA0LTMxLjYwNgoJYy0xNy40MjUsMC0zMS42MDIsMTQuMTc4LTMxLjYwMiwzMS42MDZjMCwxMy45MzEsOS4wNjQsMjUuNzc2LDIxLjYwMiwyOS45NzF2NDEuOTcxYy0yMi44OTYsMy40MzYtNDIuMDI5LDE4LjQ4Ni01MS4yMjcsMzguOTM3CglsLTYyLjU5Ny0xOS4yMjdjMC4xODgtMS41NDcsMC4yOTYtMy4xMTksMC4yOTYtNC43MTZjMC0yMS40NjgtMTcuNDY0LTM4LjkzNC0zOC45MzEtMzguOTM0QzE3LjQ2NSw4MC40MDQsMCw5Ny44NywwLDExOS4zMzgKCWMwLDIxLjQ2NywxNy40NjUsMzguOTMyLDM4LjkzNSwzOC45MzJjMTIuNzIsMCwyNC4wMzItNi4xMzMsMzEuMTQxLTE1LjU5NWw2NC43MiwxOS44NzljLTAuMzI1LDIuNjc1LTAuNTEzLDUuMzkyLTAuNTEzLDguMTUzCgljMCwxOCw3LjEzOCwzNC4zNTUsMTguNzE0LDQ2LjQxOWwtMjguMTk1LDMwLjAwOGMtNC4xMTUtMS44MzctOC42NjgtMi44NjctMTMuNDU5LTIuODY3Yy0xOC4yNzksMC0zMy4xNDgsMTQuODctMzMuMTQ4LDMzLjE0OAoJYzAsMTguMjc2LDE0Ljg2OSwzMy4xNDUsMzMuMTQ4LDMzLjE0NWMxOC4yNzYsMCwzMy4xNDYtMTQuODY5LDMzLjE0Ni0zMy4xNDVjMC02LjIxNi0xLjcyMy0xMi4wMzUtNC43MTEtMTcuMDEybDI5LjEyOC0zMS4wMDIKCWM5LjYzMyw1LjM1MywyMC43MDcsOC40MTQsMzIuNDg4LDguNDE0YzExLjI1NCwwLDIxLjg2My0yLjc5OCwzMS4xOS03LjcxNWwyOS4wNjQsNDQuMTkzYy03LjA4MSw3LjA1NC0xMS40NzEsMTYuODA4LTExLjQ3MSwyNy41NjgKCWMwLDIxLjQ2OCwxNy40NjYsMzguOTM0LDM4LjkzNCwzOC45MzRzMzguOTM0LTE3LjQ2NSwzOC45MzQtMzguOTM0YzAtMjEuNDY3LTE3LjQ2Ni0zOC45MzItMzguOTM0LTM4LjkzMgoJYy0zLjQ5OCwwLTYuODg4LDAuNDcxLTEwLjExNSwxLjM0MWwtMzAuMjc1LTQ2LjAzM2M3LjE1NS03LjEyNCwxMi43MDItMTUuODUzLDE2LjA4LTI1LjU4N2wxOS4xNjgsMy4zMjEKCWMxLjg3OSwxMy4yNjcsMTMuMzA1LDIzLjUwNSwyNy4wODIsMjMuNTA1YzE1LjA4NywwLDI3LjM2MS0xMi4yNzQsMjcuMzYxLTI3LjM2MUMzMzguNDEsMTc3LjAzMSwzMjYuMTM2LDE2NC43NTgsMzExLjA0OSwxNjQuNzU4egoJIE0xNTQuMjgyLDE3MC43MDdjMC0yNS45NzcsMjEuMTM0LTQ3LjExMSw0Ny4xMS00Ny4xMTFjMjUuOTc4LDAsNDcuMTExLDIxLjEzNCw0Ny4xMTEsNDcuMTExYzAsMjUuOTc2LTIxLjEzNCw0Ny4xMDktNDcuMTExLDQ3LjEwOQoJQzE3NS40MTYsMjE3LjgxNiwxNTQuMjgyLDE5Ni42ODMsMTU0LjI4MiwxNzAuNzA3eiIvPgo8L3N2Zz4=' type='image/x-icon'>
    <style>
      <!-- https://cdn.jsdelivr.net/npm/mind-elixir@^5.3.4/dist/MindElixir.css -->
      .map-container{-webkit-tap-highlight-color:rgba(0,0,0,0);font-family:-apple-system,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Microsoft YaHei,Source Han Sans SC,Noto Sans CJK SC,WenQuanYi Micro Hei,sans-serif;-webkit-user-select:none;user-select:none;height:100%;width:100%;overflow:hidden;font-size:15px;outline:none;touch-action:none;background-color:var(--bgcolor)}.map-container p{margin:0}.map-container *{box-sizing:border-box}.map-container::-webkit-scrollbar{width:0px;height:0px}.map-container .selected{outline:2px solid var(--selected);outline-offset:1px}.map-container.space-pressed,.map-container.space-pressed *{cursor:grab!important}.map-container.space-pressed:active,.map-container.space-pressed:active *{cursor:grabbing!important}.map-container .hyper-link{text-decoration:none;margin-left:.3em}.map-container me-main>me-wrapper>me-parent>me-epd{top:50%;transform:translateY(-50%)}.map-container me-epd{top:100%;transform:translateY(-50%)}.map-container .lhs{direction:rtl}.map-container .lhs>me-wrapper>me-parent>me-epd{left:-10px}.map-container .lhs me-epd{left:5px}.map-container .lhs me-tpc{direction:ltr}.map-container .rhs>me-wrapper>me-parent>me-epd{right:-10px}.map-container .rhs me-epd{right:5px}.map-container .map-canvas{position:relative;-webkit-user-select:none;user-select:none;width:fit-content;transform:scale(1)}.map-container .map-canvas me-nodes{position:relative;display:flex;justify-content:center;align-items:center;height:max-content;width:max-content;padding:var(--map-padding)}.map-container me-main>me-wrapper{position:relative;margin:var(--main-gap-y) var(--main-gap-x)}.map-container me-main>me-wrapper>me-parent{margin:10px;padding:0}.map-container me-main>me-wrapper>me-parent>me-tpc{border-radius:var(--main-radius);background-color:var(--main-bgcolor);border:2px solid var(--main-color);color:var(--main-color);padding:8px 25px}.map-container me-wrapper{display:block;pointer-events:none;width:fit-content}.map-container me-children,.map-container me-parent{display:inline-block;vertical-align:middle}.map-container me-root{position:relative;margin:45px 0;z-index:10}.map-container me-root me-tpc{font-size:25px;color:var(--root-color);padding:10px 30px;border-radius:var(--root-radius);border:var(--root-border-color) 2px solid;background-color:var(--root-bgcolor)}.map-container me-parent{position:relative;cursor:pointer;padding:6px var(--node-gap-x);margin-top:var(--node-gap-y);z-index:10}.map-container me-parent me-tpc{position:relative;border-radius:3px;color:var(--color);padding:var(--topic-padding)}.map-container me-parent me-tpc .insert-preview{position:absolute;width:100%;left:0;z-index:9}.map-container me-parent me-tpc .show{background:#7ad5ff;pointer-events:none;opacity:.7;border-radius:3px}.map-container me-parent me-tpc .before{height:14px;top:-14px}.map-container me-parent me-tpc .in{height:100%;top:0}.map-container me-parent me-tpc .after{height:14px;bottom:-14px}.map-container me-parent me-epd{position:absolute;height:18px;width:18px;opacity:.8;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdD0iMTY1NjY1NDcxNzI0MiIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHZlcnNpb249IjEuMSIKICAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+CiAgICA8cGF0aCBkPSJNNTEyIDc0LjY2NjY2N0MyNzAuOTMzMzMzIDc0LjY2NjY2NyA3NC42NjY2NjcgMjcwLjkzMzMzMyA3NC42NjY2NjcgNTEyUzI3MC45MzMzMzMgOTQ5LjMzMzMzMyA1MTIgOTQ5LjMzMzMzMyA5NDkuMzMzMzMzIDc1My4wNjY2NjcgOTQ5LjMzMzMzMyA1MTIgNzUzLjA2NjY2NyA3NC42NjY2NjcgNTEyIDc0LjY2NjY2N3oiIHN0cm9rZS13aWR0aD0iNTQiIHN0cm9rZT0nYmxhY2snIGZpbGw9J3doaXRlJyA+PC9wYXRoPgogICAgPHBhdGggZD0iTTY4Mi42NjY2NjcgNDgwaC0xMzguNjY2NjY3VjM0MS4zMzMzMzNjMC0xNy4wNjY2NjctMTQuOTMzMzMzLTMyLTMyLTMycy0zMiAxNC45MzMzMzMtMzIgMzJ2MTM4LjY2NjY2N0gzNDEuMzMzMzMzYy0xNy4wNjY2NjcgMC0zMiAxNC45MzMzMzMtMzIgMzJzMTQuOTMzMzMzIDMyIDMyIDMyaDEzOC42NjY2NjdWNjgyLjY2NjY2N2MwIDE3LjA2NjY2NyAxNC45MzMzMzMgMzIgMzIgMzJzMzItMTQuOTMzMzMzIDMyLTMydi0xMzguNjY2NjY3SDY4Mi42NjY2NjdjMTcuMDY2NjY3IDAgMzItMTQuOTMzMzMzIDMyLTMycy0xNC45MzMzMzMtMzItMzItMzJ6Ij48L3BhdGg+Cjwvc3ZnPg==);background-repeat:no-repeat;background-size:contain;background-position:center;pointer-events:all;z-index:9}.map-container me-parent me-epd.minus{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdD0iMTY1NjY1NTU2NDk4NSIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIHZlcnNpb249IjEuMSIKICAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+CiAgICA8cGF0aCBkPSJNNTEyIDc0LjY2NjY2N0MyNzAuOTMzMzMzIDc0LjY2NjY2NyA3NC42NjY2NjcgMjcwLjkzMzMzMyA3NC42NjY2NjcgNTEyUzI3MC45MzMzMzMgOTQ5LjMzMzMzMyA1MTIgOTQ5LjMzMzMzMyA5NDkuMzMzMzMzIDc1My4wNjY2NjcgOTQ5LjMzMzMzMyA1MTIgNzUzLjA2NjY2NyA3NC42NjY2NjcgNTEyIDc0LjY2NjY2N3oiIHN0cm9rZS13aWR0aD0iNTQiIHN0cm9rZT0nYmxhY2snIGZpbGw9J3doaXRlJyA+PC9wYXRoPgogICAgPHBhdGggZD0iTTY4Mi42NjY2NjcgNTQ0SDM0MS4zMzMzMzNjLTE3LjA2NjY2NyAwLTMyLTE0LjkzMzMzMy0zMi0zMnMxNC45MzMzMzMtMzIgMzItMzJoMzQxLjMzMzMzNGMxNy4wNjY2NjcgMCAzMiAxNC45MzMzMzMgMzIgMzJzLTE0LjkzMzMzMyAzMi0zMiAzMnoiPjwvcGF0aD4KPC9zdmc+)!important;transition:opacity .3s;opacity:0}@media(hover:hover){.map-container me-parent me-epd.minus:hover{opacity:.8}}@media(hover:none){.map-container me-parent me-epd.minus{opacity:.8}}.map-container .icon{width:1em;height:1em;vertical-align:-.15em;fill:currentColor;overflow:hidden}.map-container .lines,.map-container .summary,.map-container .subLines,.map-container .topiclinks,.map-container .linkcontroller{position:absolute;height:102%;width:100%;top:0;left:0}.map-container .topiclinks,.map-container .linkcontroller,.map-container .summary{pointer-events:none;z-index:20}.map-container .summary>g,.map-container .topiclinks>g{cursor:pointer;pointer-events:stroke;z-index:20}.map-container .label-container{z-index:21}.map-container .lines,.map-container .subLines{pointer-events:none}.map-container #input-box{position:absolute;top:0;left:0;width:max-content;max-width:35em;direction:ltr;-webkit-user-select:auto;user-select:auto;pointer-events:auto;color:var(--color);background-color:var(--bgcolor);outline:1px solid #ccc;border-radius:2px;z-index:100}.map-container me-tpc{display:block;max-width:35em;white-space:pre-wrap;pointer-events:all}.map-container me-tpc>*{pointer-events:none}.map-container me-tpc>a,.map-container me-tpc>iframe{pointer-events:auto}.map-container me-tpc>.text{display:inline-block}.map-container me-tpc>.text a{pointer-events:auto}.map-container me-tpc>img{display:block;margin-bottom:8px;object-fit:cover}.map-container .circle{position:absolute;height:10px;width:10px;margin-top:-5px;margin-left:-5px;border-radius:100%;background:#757575;border:2px solid #ffffff;z-index:50;cursor:pointer}.map-container .tags{direction:ltr}.map-container .tags span{display:inline-block;border-radius:3px;padding:2px 4px;background:#d6f0f8;color:#276f86;margin:2px 4px 0 0;font-size:12px;line-height:1.3em}.map-container .icons{display:inline-block;direction:ltr;margin-left:5px}.map-container .icons span{display:inline-block;line-height:1.3em}.map-container .mind-elixir-ghost{position:fixed;top:-100%;left:-100%;box-sizing:content-box;opacity:.5;background-color:var(--main-bgcolor);border:2px solid var(--main-color);color:var(--main-color);max-width:200px;width:fit-content;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding:8px 16px;border-radius:6px}.map-container .selection-area{background:#4f90f22d;border:1px solid #4f90f2}.map-container .svg-label{position:absolute;left:0;top:0;display:flex;align-items:center;word-wrap:break-word;overflow-wrap:break-word;-webkit-hyphens:auto;hyphens:auto;line-height:1.2;padding:2px;pointer-events:auto;cursor:pointer;z-index:10;max-width:200px;border-radius:3px;padding:var(--topic-padding)}.map-container h1{font-size:1.5rem;font-weight:700;color:var(--selected)}.map-container h2{font-size:1.25rem;font-weight:600;color:var(--selected)}.map-container h3{font-size:1.125rem;font-weight:600;color:var(--selected)}.map-container h4{font-size:1rem;font-weight:600;color:var(--selected)}.map-container h5{font-size:.875rem;font-weight:600;color:var(--selected)}.map-container h6{font-size:.875rem;font-weight:500;margin:.1rem 0;color:var(--selected);font-style:italic}.map-container strong.asterisk-emphasis,.map-container em{color:var(--selected)}.map-container strong.underscore-emphasis{background:#ffeb3b40;padding:.05em .15em;border-radius:.15em}.map-container a{color:var(--selected)}.map-container a:hover{color:var(--selected);text-decoration:underline}.map-container .context-menu{position:fixed;top:0;left:0;width:100%;height:100%;z-index:99}.map-container .context-menu .menu-list{position:fixed;list-style:none;margin:0;padding:0;color:var(--panel-color);box-shadow:0 12px 15px #0003;border-radius:5px;overflow:hidden}.map-container .context-menu .menu-list li{min-width:200px;overflow:hidden;white-space:nowrap;padding:6px 10px;background:var(--panel-bgcolor);border-bottom:1px solid var(--panel-border-color);cursor:pointer}.map-container .context-menu .menu-list li span{line-height:20px}.map-container .context-menu .menu-list li a{color:#333;text-decoration:none}.map-container .context-menu .menu-list li.disabled{display:none}.map-container .context-menu .menu-list li:hover{filter:brightness(.95)}.map-container .context-menu .menu-list li:last-child{border-bottom:0}.map-container .context-menu .menu-list li span:last-child{float:right}.map-container .context-menu .key{font-size:10px;background-color:#f1f1f1;color:#333;padding:2px 5px;border-radius:3px}.map-container .tips{position:absolute;bottom:28px;left:50%;transform:translate(-50%);color:var(--panel-color);background:var(--panel-bgcolor);opacity:.8;padding:5px 10px;border-radius:5px;font-weight:700}.mind-elixir-toolbar{position:absolute;color:var(--panel-color);background:var(--panel-bgcolor);padding:10px;border-radius:5px;box-shadow:0 1px 2px #0003}.mind-elixir-toolbar svg{display:inline-block}.mind-elixir-toolbar span:active{opacity:.5}.mind-elixir-toolbar.rb{right:20px;bottom:20px}.mind-elixir-toolbar.rb span+span{margin-left:10px}.mind-elixir-toolbar.lt{font-size:20px;left:20px;top:20px}.mind-elixir-toolbar.lt span{display:block}.mind-elixir-toolbar.lt span+span{margin-top:10px}
    </style>
    <style>
      * {
        box-sizing: border-box;
      }
      #map {
        height: 98vh;
        width: 100%;
      }
      #for-server {
        display: flex;
        position: absolute;
        right: 30px;
        top: 5px;
        z-index: 2;
      }
      .image {
        width: 3vmin;
        height: 3vmin;
        margin-right: 10px;
        cursor: pointer;
      }
      .btn {
        width: 100%;
      }
      .btn:hover svg * {
        fill: red;
      }
      .image:active {
        transform: scale(0.6);
        transition-duration: 0.06s;
      }
      .para {
        display: block;
        height: 3vmin;
        width: 10vw;
        outline: none;
        border-radius: 8px;
        border: 1px solid black;
        margin-right: 10px;
        font-size: 2vmin;
      }
    </style>
    <!--<script type="module">
      import MindElixir from "https://cdn.jsdelivr.net/npm/mind-elixir@^5.3.4/dist/MindElixir.js";
      let mind = new MindElixir({
        el: '#map',
        direction: MindElixir.LEFT,
        draggable: true, // default true
        contextMenu: true, // default true
        toolBar: true, // default true
        nodeMenu: true, // default true
        keypress: true, // default true
        allowUndo: true
      })
      mind.init(MindElixir.new('root'))
      console.log(mind)
    </script>-->
  </head>
  <body>
    <div id='for-server'>
      <div>
        <select id='select-mindmap' class='para' title='jump to previous mindmap' autocomplete="off">
          <option value='mindmap' selected>mindmap</option>
        </select>
      </div>
      <div>
        <input id='input-label' class='para' title='write a brief description for the current mindmap' type='text' placeholder='mindmap label'>
      </div>
      <div id='new' class='image' title='create new mindmap'>
        <!--<img src='../../assets/plus-add-create-new-cross-svgrepo-com.svg' aria-hidden='true' />-->
        <span class='btn'>
          <?xml version="1.0" encoding="UTF-8" standalone="no"?>
          <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
          <svg fill="#000000" viewBox="0 0 64 64" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
            <rect id="Icons" x="-896" y="-64" width="1280" height="800" style="fill:none;"/>
            <path id="plus" d="M30.034,29.948l0,-21.983l3.741,0l0,21.983l22.203,0l0,3.741l-22.203,0l0,22.203l-3.741,0l0,-22.203l-22.008,0l0,-3.741l22.008,0Z"/>
          </svg>
        </span>
      </div>
      <a href='http://127.0.0.1:8081/download/mindmap' id='save' class='image' title='download current mindmap as html file'>
        <!--<img src='../../assets/download-square-svgrepo-com.svg' aria-hidden='true' />-->
        <span class='btn'>
          <?xml version="1.0" encoding="utf-8"?>
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 6.25C12.4142 6.25 12.75 6.58579 12.75 7V12.1893L14.4697 10.4697C14.7626 10.1768 15.2374 10.1768 15.5303 10.4697C15.8232 10.7626 15.8232 11.2374 15.5303 11.5303L12.5303 14.5303C12.3897 14.671 12.1989 14.75 12 14.75C11.8011 14.75 11.6103 14.671 11.4697 14.5303L8.46967 11.5303C8.17678 11.2374 8.17678 10.7626 8.46967 10.4697C8.76256 10.1768 9.23744 10.1768 9.53033 10.4697L11.25 12.1893V7C11.25 6.58579 11.5858 6.25 12 6.25Z" fill="#1C274C"/>
            <path d="M7.25 17C7.25 16.5858 7.58579 16.25 8 16.25H16C16.4142 16.25 16.75 16.5858 16.75 17C16.75 17.4142 16.4142 17.75 16 17.75H8C7.58579 17.75 7.25 17.4142 7.25 17Z" fill="#1C274C"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M11.9426 1.25C9.63423 1.24999 7.82519 1.24998 6.4137 1.43975C4.96897 1.63399 3.82895 2.03933 2.93414 2.93414C2.03933 3.82895 1.63399 4.96897 1.43975 6.41371C1.24998 7.82519 1.24999 9.63423 1.25 11.9426V12.0574C1.24999 14.3658 1.24998 16.1748 1.43975 17.5863C1.63399 19.031 2.03933 20.1711 2.93414 21.0659C3.82895 21.9607 4.96897 22.366 6.4137 22.5603C7.82519 22.75 9.63423 22.75 11.9426 22.75H12.0574C14.3658 22.75 16.1748 22.75 17.5863 22.5603C19.031 22.366 20.1711 21.9607 21.0659 21.0659C21.9607 20.1711 22.366 19.031 22.5603 17.5863C22.75 16.1748 22.75 14.3658 22.75 12.0574V11.9426C22.75 9.63423 22.75 7.82519 22.5603 6.41371C22.366 4.96897 21.9607 3.82895 21.0659 2.93414C20.1711 2.03933 19.031 1.63399 17.5863 1.43975C16.1748 1.24998 14.3658 1.24999 12.0574 1.25H11.9426ZM3.9948 3.9948C4.56445 3.42514 5.33517 3.09825 6.61358 2.92637C7.91356 2.75159 9.62177 2.75 12 2.75C14.3782 2.75 16.0864 2.75159 17.3864 2.92637C18.6648 3.09825 19.4355 3.42514 20.0052 3.9948C20.5749 4.56445 20.9018 5.33517 21.0736 6.61358C21.2484 7.91356 21.25 9.62178 21.25 12C21.25 14.3782 21.2484 16.0864 21.0736 17.3864C20.9018 18.6648 20.5749 19.4355 20.0052 20.0052C19.4355 20.5749 18.6648 20.9018 17.3864 21.0736C16.0864 21.2484 14.3782 21.25 12 21.25C9.62177 21.25 7.91356 21.2484 6.61358 21.0736C5.33517 20.9018 4.56445 20.5749 3.9948 20.0052C3.42514 19.4355 3.09825 18.6648 2.92637 17.3864C2.75159 16.0864 2.75 14.3782 2.75 12C2.75 9.62178 2.75159 7.91356 2.92637 6.61358C3.09825 5.33517 3.42514 4.56445 3.9948 3.9948Z" fill="#1C274C"/>
          </svg>
        </span>
      </a>
      <div id='save-image' class='image' title='export mindmap as image'>
        <!--<img src='../../assets/image-svgrepo-com.svg' aria-hidden='true' />-->
        <span class='btn'>
          <?xml version="1.0" encoding="utf-8"?>
          <svg fill="#000000" viewBox="0 0 36 36" version="1.1"  preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <path d="M32,4H4A2,2,0,0,0,2,6V30a2,2,0,0,0,2,2H32a2,2,0,0,0,2-2V6A2,2,0,0,0,32,4ZM4,30V6H32V30Z" class="clr-i-outline clr-i-outline-path-1"></path><path d="M8.92,14a3,3,0,1,0-3-3A3,3,0,0,0,8.92,14Zm0-4.6A1.6,1.6,0,1,1,7.33,11,1.6,1.6,0,0,1,8.92,9.41Z" class="clr-i-outline clr-i-outline-path-2"></path><path d="M22.78,15.37l-5.4,5.4-4-4a1,1,0,0,0-1.41,0L5.92,22.9v2.83l6.79-6.79L16,22.18l-3.75,3.75H15l8.45-8.45L30,24V21.18l-5.81-5.81A1,1,0,0,0,22.78,15.37Z" class="clr-i-outline clr-i-outline-path-3"></path>
            <rect x="0" y="0" width="36" height="36" fill-opacity="0"/>
          </svg>
        </span>
      </div>
      <div id='update' class='image' title='record the current mindmap status'>
        <!--<img src='../../assets/cloud-upload-svgrepo-com.svg' aria-hidden='true' />-->
        <span class='btn'>
          <?xml version="1.0" encoding="utf-8"?>
          <svg fill="#000000" viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M1451.06 557.963C1456.76 557.07 1462.44 556.179 1468.24 556.179C1717.38 556.179 1920 761.2 1920 1013.31C1920 1265.41 1717.38 1470.43 1468.24 1470.43H1355.29V1356.15H1468.24C1655.04 1356.15 1807.06 1202.33 1807.06 1013.31C1807.06 824.283 1655.04 670.46 1468.24 670.46C1467.28 670.46 1466.34 670.632 1465.41 670.803C1464.48 670.975 1463.55 671.146 1462.59 671.146C1463.2 676.832 1463.97 682.485 1464.73 688.143C1466.48 701.135 1468.24 714.146 1468.24 727.601C1468.24 772.4 1462.48 816.855 1451.29 859.825L1342.08 830.569C1350.78 797.084 1355.29 762.571 1355.29 727.601C1355.29 507.038 1177.98 327.616 960 327.616C747.558 327.616 574.871 498.581 566.287 711.373C604.574 730.115 640.602 753.772 671.887 784.628L592.941 866.339C539.746 813.77 469.609 784.742 395.294 784.742C239.661 784.742 112.941 912.852 112.941 1070.45C112.941 1228.04 239.661 1356.15 395.294 1356.15H564.706V1470.43H395.294C177.318 1470.43 0 1291.01 0 1070.45C0 849.883 177.318 670.46 395.294 670.46C416.188 670.46 436.631 673.203 456.847 676.517C482.598 417.098 697.073 213.334 960 213.334C1181.82 213.334 1368.85 358.7 1438.08 559.607C1442.45 559.312 1446.76 558.637 1451.06 557.963ZM717.572 1282.27L637.722 1201.47L960.056 875.31L1282.28 1201.47L1202.43 1282.27L1016.53 1094.16V1813.33H903.586V1094.16L717.572 1282.27Z"/>
          </svg>
        </span>
      </div>
    </div>
    <div id="map"></div>
  </body>
  <script>
  // https://cdn.jsdelivr.net/npm/mind-elixir@^5.3.4/dist/MindElixir.js
const be = {
  name: "Latte",
  type: "light",
  palette: ["#dd7878", "#ea76cb", "#8839ef", "#e64553", "#fe640b", "#df8e1d", "#40a02b", "#209fb5", "#1e66f5", "#7287fd"],
  cssVar: {
    "--node-gap-x": "30px",
    "--node-gap-y": "10px",
    "--main-gap-x": "65px",
    "--main-gap-y": "45px",
    "--root-radius": "30px",
    "--main-radius": "20px",
    "--root-color": "#ffffff",
    "--root-bgcolor": "#4c4f69",
    "--root-border-color": "rgba(0, 0, 0, 0)",
    "--main-color": "#444446",
    "--main-bgcolor": "#ffffff",
    "--topic-padding": "3px",
    "--color": "#777777",
    "--bgcolor": "#f6f6f6",
    "--selected": "#4dc4ff",
    "--accent-color": "#e64553",
    "--panel-color": "#444446",
    "--panel-bgcolor": "#ffffff",
    "--panel-border-color": "#eaeaea",
    "--map-padding": "50px"
  }
}, we = {
  name: "Dark",
  type: "dark",
  palette: ["#848FA0", "#748BE9", "#D2F9FE", "#4145A5", "#789AFA", "#706CF4", "#EF987F", "#775DD5", "#FCEECF", "#DA7FBC"],
  cssVar: {
    "--node-gap-x": "30px",
    "--node-gap-y": "10px",
    "--main-gap-x": "65px",
    "--main-gap-y": "45px",
    "--root-radius": "30px",
    "--main-radius": "20px",
    "--root-color": "#ffffff",
    "--root-bgcolor": "#2d3748",
    "--root-border-color": "rgba(255, 255, 255, 0.1)",
    "--main-color": "#ffffff",
    "--main-bgcolor": "#4c4f69",
    "--topic-padding": "3px",
    "--color": "#cccccc",
    "--bgcolor": "#252526",
    "--selected": "#4dc4ff",
    "--accent-color": "#789AFA",
    "--panel-color": "#ffffff",
    "--panel-bgcolor": "#2d3748",
    "--panel-border-color": "#696969",
    "--map-padding": "50px 80px"
  }
};
function ue(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
}
const se = function(e, t) {
  if (t.id === e)
    return t;
  if (t.children && t.children.length) {
    for (let n = 0; n < t.children.length; n++) {
      const o = se(e, t.children[n]);
      if (o) return o;
    }
    return null;
  } else
    return null;
}, R = (e, t) => {
  if (e.parent = t, e.children)
    for (let n = 0; n < e.children.length; n++)
      R(e.children[n], e);
}, z = (e, t, n) => {
  if (e.expanded = t, e.children)
    if (n === void 0 || n > 0) {
      const o = n !== void 0 ? n - 1 : void 0;
      e.children.forEach((s) => {
        z(s, t, o);
      });
    } else
      e.children.forEach((o) => {
        z(o, !1);
      });
};
function xe(e) {
  if (e.id = W(), e.children)
    for (let t = 0; t < e.children.length; t++)
      xe(e.children[t]);
}
function ie(e, t, n, o) {
  const s = o - t, i = e - n;
  let l = Math.atan(Math.abs(s) / Math.abs(i)) / 3.14 * 180;
  if (isNaN(l)) return;
  i < 0 && s > 0 && (l = 180 - l), i < 0 && s < 0 && (l = 180 + l), i > 0 && s < 0 && (l = 360 - l);
  const r = 12, c = 30, a = l + c, h = l - c;
  return {
    x1: n + Math.cos(Math.PI * a / 180) * r,
    y1: o - Math.sin(Math.PI * a / 180) * r,
    x2: n + Math.cos(Math.PI * h / 180) * r,
    y2: o - Math.sin(Math.PI * h / 180) * r
  };
}
function W() {
  return ((/* @__PURE__ */ new Date()).getTime().toString(16) + Math.random().toString(16).substr(2)).substr(2, 16);
}
const ft = function() {
  const e = W();
  return {
    topic: this.newTopicName,
    id: e
  };
};
function Ee(e) {
  return JSON.parse(
    JSON.stringify(e, (n, o) => {
      if (n !== "parent")
        return o;
    })
  );
}
const $ = (e, t) => {
  let n = 0, o = 0;
  for (; t && t !== e; )
    n += t.offsetLeft, o += t.offsetTop, t = t.offsetParent;
  return { offsetLeft: n, offsetTop: o };
}, k = (e, t) => {
  for (const n in t)
    e.setAttribute(n, t[n]);
}, pe = (e) => e ? e.tagName === "ME-TPC" : !1, ae = (e) => e.filter((t) => t.nodeObj.parent).filter((t, n, o) => {
  for (let s = 0; s < o.length; s++) {
    if (t === o[s]) continue;
    const { parent: i } = t.nodeObj;
    if (i === o[s].nodeObj)
      return !1;
  }
  return !0;
}), Xe = (e) => {
  const t = /translate\(([^,]+),\s*([^)]+)\)/, n = e.match(t);
  return n ? { x: parseFloat(n[1]), y: parseFloat(n[2]) } : { x: 0, y: 0 };
}, Ce = function(e) {
  for (let t = 0; t < e.length; t++) {
    const { dom: n, evt: o, func: s } = e[t];
    n.addEventListener(o, s);
  }
  return function() {
    for (let n = 0; n < e.length; n++) {
      const { dom: o, evt: s, func: i } = e[n];
      o.removeEventListener(s, i);
    }
  };
}, D = {
  LHS: "lhs",
  RHS: "rhs"
}, ut = (e) => {
  const t = e.map.querySelectorAll(".lhs>me-wrapper>me-parent>me-tpc");
  e.selectNode(t[Math.ceil(t.length / 2) - 1]);
}, pt = (e) => {
  const t = e.map.querySelectorAll(".rhs>me-wrapper>me-parent>me-tpc");
  e.selectNode(t[Math.ceil(t.length / 2) - 1]);
}, gt = (e) => {
  e.selectNode(e.map.querySelector("me-root>me-tpc"));
}, mt = function(e, t) {
  const n = t.parentElement.parentElement.parentElement.previousSibling;
  if (n) {
    const o = n.firstChild;
    e.selectNode(o);
  }
}, yt = function(e, t) {
  const n = t.parentElement.nextSibling;
  if (n && n.firstChild) {
    const o = n.firstChild.firstChild.firstChild;
    e.selectNode(o);
  }
}, De = function(e, t) {
  const n = e.currentNode || e.currentNodes?.[0];
  if (!n) return;
  const o = n.nodeObj, s = n.offsetParent.offsetParent.parentElement;
  o.parent ? s.className === t ? yt(e, n) : o.parent?.parent ? mt(e, n) : gt(e) : t === D.LHS ? ut(e) : pt(e);
}, Pe = function(e, t) {
  const n = e.currentNode;
  if (!n || !n.nodeObj.parent) return;
  const s = t + "Sibling", i = n.parentElement.parentElement[s];
  i ? e.selectNode(i.firstChild.firstChild) : e.selectNode(n);
}, re = function(e, t, n) {
  const { scaleVal: o, scaleSensitivity: s } = e;
  switch (t) {
    case "in":
      e.scale(o + s, n);
      break;
    case "out":
      e.scale(o - s, n);
  }
};
function vt(e, t) {
  t = t === !0 ? {} : t;
  const n = () => {
    e.currentArrow ? e.removeArrow() : e.currentSummary ? e.removeSummary(e.currentSummary.summaryObj.id) : e.currentNodes && e.removeNodes(e.currentNodes);
  };
  let o = !1, s = null;
  const i = (r) => {
    const c = e.nodeData;
    if (r.key === "0")
      for (const a of c.children)
        z(a, !1);
    if (r.key === "=")
      for (const a of c.children)
        z(a, !0);
    if (["1", "2", "3", "4", "5", "6", "7", "8", "9"].includes(r.key))
      for (const a of c.children)
        z(a, !0, Number(r.key) - 1);
    e.refresh(), e.toCenter(), o = !1, s && (clearTimeout(s), s = null, e.container.removeEventListener("keydown", i));
  }, l = {
    Enter: (r) => {
      r.shiftKey ? e.insertSibling("before") : r.ctrlKey || r.metaKey ? e.insertParent() : e.insertSibling("after");
    },
    Tab: () => {
      e.addChild();
    },
    F1: () => {
      e.toCenter();
    },
    F2: () => {
      e.currentSummary ? e.editSummary(e.currentSummary) : e.currentArrow ? e.editArrowLabel(e.currentArrow) : e.beginEdit();
    },
    ArrowUp: (r) => {
      if (r.altKey)
        e.moveUpNode();
      else {
        if (r.metaKey || r.ctrlKey)
          return e.initSide();
        Pe(e, "previous");
      }
    },
    ArrowDown: (r) => {
      r.altKey ? e.moveDownNode() : Pe(e, "next");
    },
    ArrowLeft: (r) => {
      if (r.metaKey || r.ctrlKey)
        return e.initLeft();
      De(e, D.LHS);
    },
    ArrowRight: (r) => {
      if (r.metaKey || r.ctrlKey)
        return e.initRight();
      De(e, D.RHS);
    },
    PageUp: () => e.moveUpNode(),
    PageDown: () => {
      e.moveDownNode();
    },
    c: (r) => {
      (r.metaKey || r.ctrlKey) && (e.waitCopy = e.currentNodes);
    },
    x: (r) => {
      (r.metaKey || r.ctrlKey) && (e.waitCopy = e.currentNodes, n());
    },
    v: (r) => {
      !e.waitCopy || !e.currentNode || (r.metaKey || r.ctrlKey) && (e.waitCopy.length === 1 ? e.copyNode(e.waitCopy[0], e.currentNode) : e.copyNodes(e.waitCopy, e.currentNode));
    },
    "=": (r) => {
      (r.metaKey || r.ctrlKey) && re(e, "in");
    },
    "-": (r) => {
      (r.metaKey || r.ctrlKey) && re(e, "out");
    },
    0: (r) => {
      if (r.metaKey || r.ctrlKey) {
        if (o)
          return;
        e.scale(1);
      }
    },
    k: (r) => {
      (r.metaKey || r.ctrlKey) && (o = !0, s && (clearTimeout(s), e.container.removeEventListener("keydown", i)), s = window.setTimeout(() => {
        o = !1, s = null;
      }, 2e3), e.container.addEventListener("keydown", i));
    },
    Delete: n,
    Backspace: n,
    ...t
  };
  e.container.onkeydown = (r) => {
    if (r.preventDefault(), !e.editable) return;
    const c = l[r.key];
    c && c(r);
  };
}
function bt(e) {
  const { dragMoveHelper: t } = e;
  let n = 0;
  e.spacePressed = !1;
  const o = (d) => {
    if (d.button !== 0) return;
    if (e.helper1?.moved) {
      e.helper1.clear();
      return;
    }
    if (e.helper2?.moved) {
      e.helper2.clear();
      return;
    }
    if (t.moved) {
      t.clear();
      return;
    }
    const f = d.target;
    if (f.tagName === "ME-EPD")
      d.ctrlKey || d.metaKey ? e.expandNodeAll(f.previousSibling) : e.expandNode(f.previousSibling);
    else if (f.tagName === "ME-TPC" && e.currentNodes.length > 1)
      e.selectNode(f);
    else if (!e.editable)
      return;
    const y = f.closest(".svg-label");
    if (y) {
      const E = y.dataset.svgId, x = y.dataset.type, b = document.getElementById(E);
      if (b) {
        if (x === "arrow") {
          e.selectArrow(b);
          return;
        } else if (x === "summary") {
          e.selectSummary(b);
          return;
        }
      }
    }
    if (f.closest(".topiclinks")) {
      const E = f.closest("g");
      if (E) {
        e.selectArrow(E);
        return;
      }
    }
    if (f.closest(".summary")) {
      const E = f.closest("g");
      if (E) {
        e.selectSummary(E);
        return;
      }
    }
  }, s = (d) => {
    if (!e.editable) return;
    const f = d.target;
    pe(f) && e.beginEdit(f);
    const y = f.closest(".svg-label");
    if (y) {
      const E = y.dataset.svgId, x = y.dataset.type, b = document.getElementById(E);
      if (b) {
        if (x === "arrow") {
          e.editArrowLabel(b);
          return;
        } else if (x === "summary") {
          e.editSummary(b);
          return;
        }
      }
    }
    if (f.closest(".topiclinks")) {
      const E = f.closest("g");
      if (E) {
        e.editArrowLabel(E);
        return;
      }
    }
    if (f.closest(".summary")) {
      const E = f.closest("g");
      if (E) {
        e.editSummary(E);
        return;
      }
    }
  }, i = (d) => {
    if (d.pointerType === "mouse") return;
    const f = (/* @__PURE__ */ new Date()).getTime(), y = f - n;
    y < 300 && y > 0 && s(d), n = f;
  }, l = (d) => {
    d.code === "Space" && (e.spacePressed = !0, e.container.classList.add("space-pressed"));
  }, r = (d) => {
    d.code === "Space" && (e.spacePressed = !1, e.container.classList.remove("space-pressed"));
  }, c = (d) => {
    t.moved = !1;
    const f = e.spacePressed && d.button === 0 && d.pointerType === "mouse", y = e.mouseSelectionButton === 0 ? 2 : 0, w = d.button === y && d.pointerType === "mouse";
    if (!f && !w) return;
    t.x = d.clientX, t.y = d.clientY;
    const S = d.target;
    (f || S.className !== "circle" && S.contentEditable !== "plaintext-only") && (t.mousedown = !0, S.setPointerCapture(d.pointerId));
  }, a = (d) => {
    if (d.target.contentEditable !== "plaintext-only" || e.spacePressed && t.mousedown) {
      const f = d.clientX - t.x, y = d.clientY - t.y;
      t.onMove(f, y);
    }
    t.x = d.clientX, t.y = d.clientY;
  }, h = (d) => {
    if (!t.mousedown) return;
    const f = d.target;
    f.hasPointerCapture && f.hasPointerCapture(d.pointerId) && f.releasePointerCapture(d.pointerId), t.clear();
  }, u = () => {
    t.mousedown && t.clear();
  }, g = (d) => {
    if (d.preventDefault(), d.button !== 2 || !e.editable) return;
    const f = d.target;
    pe(f) && !f.classList.contains("selected") && e.selectNode(f), setTimeout(() => {
      e.dragMoveHelper.moved || e.bus.fire("showContextMenu", d);
    }, 200);
  }, v = (d) => {
    d.stopPropagation(), d.preventDefault(), d.ctrlKey || d.metaKey ? d.deltaY < 0 ? re(e, "in", e.dragMoveHelper) : e.scaleVal - e.scaleSensitivity > 0 && re(e, "out", e.dragMoveHelper) : d.shiftKey ? e.move(-d.deltaY, 0) : e.move(-d.deltaX, -d.deltaY);
  }, { container: m } = e;
  return Ce([
    { dom: m, evt: "pointerdown", func: c },
    { dom: m, evt: "pointermove", func: a },
    { dom: m, evt: "pointerup", func: h },
    { dom: m, evt: "pointerup", func: i },
    { dom: m, evt: "click", func: o },
    { dom: m, evt: "dblclick", func: s },
    { dom: m, evt: "contextmenu", func: g },
    { dom: m, evt: "wheel", func: typeof e.handleWheel == "function" ? e.handleWheel : v },
    { dom: m, evt: "blur", func: u },
    { dom: m, evt: "keydown", func: l },
    { dom: m, evt: "keyup", func: r }
  ]);
}
function wt() {
  return {
    handlers: {},
    addListener: function(e, t) {
      this.handlers[e] === void 0 && (this.handlers[e] = []), this.handlers[e].push(t);
    },
    fire: function(e, ...t) {
      if (this.handlers[e] instanceof Array) {
        const n = this.handlers[e];
        for (let o = 0; o < n.length; o++)
          n[o](...t);
      }
    },
    removeListener: function(e, t) {
      if (!this.handlers[e]) return;
      const n = this.handlers[e];
      if (!t)
        n.length = 0;
      else if (n.length)
        for (let o = 0; o < n.length; o++)
          n[o] === t && this.handlers[e].splice(o, 1);
    }
  };
}
const le = document, xt = function() {
  this.nodes.innerHTML = "";
  const e = this.createTopic(this.nodeData);
  Se.call(this, e, this.nodeData), e.draggable = !1;
  const t = le.createElement("me-root");
  t.appendChild(e);
  const n = this.nodeData.children || [];
  if (this.direction === 2) {
    let o = 0, s = 0;
    n.map((i) => {
      i.direction === 0 ? o += 1 : i.direction === 1 ? s += 1 : o <= s ? (i.direction = 0, o += 1) : (i.direction = 1, s += 1);
    });
  }
  Et(this, n, t);
}, Et = function(e, t, n) {
  const o = le.createElement("me-main");
  o.className = D.LHS;
  const s = le.createElement("me-main");
  s.className = D.RHS;
  for (let i = 0; i < t.length; i++) {
    const l = t[i], { grp: r } = e.createWrapper(l);
    e.direction === 2 ? l.direction === 0 ? o.appendChild(r) : s.appendChild(r) : e.direction === 0 ? o.appendChild(r) : s.appendChild(r);
  }
  e.nodes.appendChild(o), e.nodes.appendChild(n), e.nodes.appendChild(s), e.nodes.appendChild(e.lines), e.nodes.appendChild(e.labelContainer);
}, Ct = function(e, t) {
  const n = le.createElement("me-children");
  for (let o = 0; o < t.length; o++) {
    const s = t[o], { grp: i } = e.createWrapper(s);
    n.appendChild(i);
  }
  return n;
}, _ = document, Ue = function(e, t) {
  const o = (this?.el ? this.el : t || document).querySelector(`[data-nodeid="me${e}"]`);
  if (!o) throw new Error(`FindEle: Node ${e} not found, maybe it's collapsed.`);
  return o;
}, Se = function(e, t) {
  if (e.innerHTML = "", t.style) {
    const n = t.style;
    for (const o in n)
      e.style[o] = n[o];
  }
  if (t.dangerouslySetInnerHTML) {
    e.innerHTML = t.dangerouslySetInnerHTML;
    return;
  }
  if (t.image) {
    const n = t.image;
    if (n.url && n.width && n.height) {
      const o = _.createElement("img");
      o.src = this.imageProxy ? this.imageProxy(n.url) : n.url, o.style.width = n.width + "px", o.style.height = n.height + "px", n.fit && (o.style.objectFit = n.fit), e.appendChild(o), e.image = o;
    }
  } else e.image && (e.image = void 0);
  {
    const n = _.createElement("span");
    n.className = "text", this.markdown ? n.innerHTML = this.markdown(t.topic, t) : n.textContent = t.topic, e.appendChild(n), e.text = n;
  }
  if (t.hyperLink) {
    const n = _.createElement("a");
    n.className = "hyper-link", n.target = "_blank", n.innerText = "??", n.href = t.hyperLink, e.appendChild(n), e.link = n;
  } else e.link && (e.link = void 0);
  if (t.icons && t.icons.length) {
    const n = _.createElement("span");
    n.className = "icons", n.innerHTML = t.icons.map((o) => `<span>${ue(o)}</span>`).join(""), e.appendChild(n), e.icons = n;
  } else e.icons && (e.icons = void 0);
  if (t.tags && t.tags.length) {
    const n = _.createElement("div");
    n.className = "tags", t.tags.forEach((o) => {
      const s = _.createElement("span");
      typeof o == "string" ? s.textContent = o : (s.textContent = o.text, o.className && (s.className = o.className), o.style && Object.assign(s.style, o.style)), n.appendChild(s);
    }), e.appendChild(n), e.tags = n;
  } else e.tags && (e.tags = void 0);
}, St = function(e, t) {
  const n = _.createElement("me-wrapper"), { p: o, tpc: s } = this.createParent(e);
  if (n.appendChild(o), !t && e.children && e.children.length > 0) {
    const i = Ne(e.expanded);
    if (o.appendChild(i), e.expanded !== !1) {
      const l = Ct(this, e.children);
      n.appendChild(l);
    }
  }
  return { grp: n, top: o, tpc: s };
}, Nt = function(e) {
  const t = _.createElement("me-parent"), n = this.createTopic(e);
  return Se.call(this, n, e), t.appendChild(n), { p: t, tpc: n };
}, kt = function(e) {
  const t = _.createElement("me-children");
  return t.append(...e), t;
}, _t = function(e) {
  const t = _.createElement("me-tpc");
  return t.nodeObj = e, t.dataset.nodeid = "me" + e.id, t.draggable = this.draggable, t;
};
function Je(e) {
  const t = _.createRange();
  t.selectNodeContents(e);
  const n = window.getSelection();
  n && (n.removeAllRanges(), n.addRange(t));
}
const Tt = function(e) {
  if (!e) return;
  const t = _.createElement("div"), n = e.nodeObj, o = n.topic, { offsetLeft: s, offsetTop: i } = $(this.nodes, e);
  this.nodes.appendChild(t), t.id = "input-box", t.textContent = o, t.contentEditable = "plaintext-only", t.spellcheck = !1;
  const l = getComputedStyle(e);
  t.style.cssText = `
  left: ${s}px;
  top: ${i}px;
  min-width:${e.offsetWidth - 8}px;
  color:${l.color};
  font-size:${l.fontSize};
  padding:${l.padding};
  margin:${l.margin}; 
  background-color:${l.backgroundColor !== "rgba(0, 0, 0, 0)" && l.backgroundColor};
  border: ${l.border};
  border-radius:${l.borderRadius}; `, this.direction === 0 && (t.style.right = "0"), Je(t), this.bus.fire("operation", {
    name: "beginEdit",
    obj: e.nodeObj
  }), t.addEventListener("keydown", (r) => {
    r.stopPropagation();
    const c = r.key;
    if (c === "Enter" || c === "Tab") {
      if (r.shiftKey) return;
      r.preventDefault(), t.blur(), this.container.focus();
    }
  }), t.addEventListener("blur", () => {
    if (!t) return;
    t.remove();
    const r = t.textContent?.trim() || "";
    r === o || r === "" || (n.topic = r, this.markdown ? e.text.innerHTML = this.markdown(n.topic, n) : e.text.textContent = r, this.linkDiv(), this.bus.fire("operation", {
      name: "finishEdit",
      obj: n,
      origin: o
    }));
  });
}, Ne = function(e) {
  const t = _.createElement("me-epd");
  return t.expanded = e !== !1, t.className = e !== !1 ? "minus" : "", t;
}, q = document, M = "http://www.w3.org/2000/svg", de = function(e) {
  const t = e.clientWidth, n = e.clientHeight, o = e.dataset, s = Number(o.x), i = Number(o.y), l = o.anchor;
  let r = s;
  l === "middle" ? r = s - t / 2 : l === "end" && (r = s - t), e.style.left = `${r}px`, e.style.top = `${i - n / 2}px`, e.style.visibility = "visible";
}, ge = function(e, t, n, o) {
  const { anchor: s = "middle", color: i, dataType: l, svgId: r } = o, c = document.createElement("div");
  c.className = "svg-label", c.style.color = i || "#666";
  const a = "label-" + r;
  return c.id = a, c.innerHTML = e, c.dataset.type = l, c.dataset.svgId = r, c.dataset.x = t.toString(), c.dataset.y = n.toString(), c.dataset.anchor = s, c;
}, Ze = function(e, t, n) {
  const o = q.createElementNS(M, "path");
  return k(o, {
    d: e,
    stroke: t || "#666",
    fill: "none",
    "stroke-width": n
  }), o;
}, U = function(e) {
  const t = q.createElementNS(M, "svg");
  return t.setAttribute("class", e), t.setAttribute("overflow", "visible"), t;
}, $e = function() {
  const e = q.createElementNS(M, "line");
  return e.setAttribute("stroke", "#4dc4ff"), e.setAttribute("fill", "none"), e.setAttribute("stroke-width", "2"), e.setAttribute("opacity", "0.45"), e;
}, Lt = function(e, t, n, o) {
  const s = q.createElementNS(M, "g");
  return [
    {
      name: "line",
      d: e
    },
    {
      name: "arrow1",
      d: t
    },
    {
      name: "arrow2",
      d: n
    }
  ].forEach((l, r) => {
    const c = l.d, a = q.createElementNS(M, "path"), h = {
      d: c,
      stroke: o?.stroke || "rgb(227, 125, 116)",
      fill: "none",
      "stroke-linecap": o?.strokeLinecap || "cap",
      "stroke-width": String(o?.strokeWidth || "2")
    };
    o?.opacity !== void 0 && (h.opacity = String(o.opacity)), k(a, h), r === 0 && a.setAttribute("stroke-dasharray", o?.strokeDasharray || "8,2");
    const u = q.createElementNS(M, "path");
    k(u, {
      d: c,
      stroke: "transparent",
      fill: "none",
      "stroke-width": "15"
    }), s.appendChild(u), s.appendChild(a), s[l.name] = a;
  }), s;
}, Qe = function(e, t, n) {
  if (!t) return;
  const o = n.label, s = t.cloneNode(!0);
  e.nodes.appendChild(s), s.id = "input-box", s.textContent = o, s.contentEditable = "plaintext-only", s.spellcheck = !1, s.style.cssText = `
    left:${t.style.left};
    top:${t.style.top}; 
    max-width: 200px;
  `, Je(s), e.scrollIntoView(s), s.addEventListener("keydown", (i) => {
    i.stopPropagation();
    const l = i.key;
    if (l === "Enter" || l === "Tab") {
      if (i.shiftKey) return;
      i.preventDefault(), s.blur(), e.container.focus();
    }
  }), s.addEventListener("blur", () => {
    if (!s) return;
    const i = s.textContent?.trim() || "";
    i === "" ? n.label = o : n.label = i, s.remove(), i !== o && (e.markdown ? t.innerHTML = e.markdown(n.label, n) : t.textContent = n.label, de(t), "parent" in n ? e.bus.fire("operation", {
      name: "finishEditSummary",
      obj: n
    }) : e.bus.fire("operation", {
      name: "finishEditArrowLabel",
      obj: n
    }));
  });
}, At = function(e) {
  const t = this.map.querySelector("me-root"), n = t.offsetTop, o = t.offsetLeft, s = t.offsetWidth, i = t.offsetHeight, l = this.map.querySelectorAll("me-main > me-wrapper");
  this.lines.innerHTML = "";
  for (let r = 0; r < l.length; r++) {
    const c = l[r], a = c.querySelector("me-tpc"), { offsetLeft: h, offsetTop: u } = $(this.nodes, a), g = a.offsetWidth, v = a.offsetHeight, m = c.parentNode.className, p = this.generateMainBranch({ pT: n, pL: o, pW: s, pH: i, cT: u, cL: h, cW: g, cH: v, direction: m, containerHeight: this.nodes.offsetHeight }), d = this.theme.palette, f = a.nodeObj.branchColor || d[r % d.length];
    if (a.style.borderColor = f, this.lines.appendChild(Ze(p, f, "3")), e && e !== c)
      continue;
    const y = U("subLines"), w = c.lastChild;
    w.tagName === "svg" && w.remove(), c.appendChild(y), et(this, y, f, c, m, !0);
  }
  this.labelContainer.innerHTML = "", this.renderArrow(), this.renderSummary(), this.bus.fire("linkDiv");
}, et = function(e, t, n, o, s, i) {
  const l = o.firstChild, r = o.children[1].children;
  if (r.length === 0) return;
  const c = l.offsetTop, a = l.offsetLeft, h = l.offsetWidth, u = l.offsetHeight;
  for (let g = 0; g < r.length; g++) {
    const v = r[g], m = v.firstChild, p = m.offsetTop, d = m.offsetLeft, f = m.offsetWidth, y = m.offsetHeight, w = m.firstChild.nodeObj.branchColor || n, S = e.generateSubBranch({ pT: c, pL: a, pW: h, pH: u, cT: p, cL: d, cW: f, cH: y, direction: s, isFirst: i });
    t.appendChild(Ze(S, w, "2"));
    const E = m.children[1];
    if (E) {
      if (!E.expanded) continue;
    } else
      continue;
    et(e, t, w, v, s);
  }
}, Oe = {
  addChild: "插入子节点",
  addParent: "插入父节点",
  addSibling: "插入同级节点",
  removeNode: "删除节点",
  focus: "专注",
  cancelFocus: "取消专注",
  moveUp: "上移",
  moveDown: "下移",
  link: "连接",
  linkBidirectional: "双向连接",
  clickTips: "请点击目标节点",
  summary: "摘要"
}, je = {
  cn: Oe,
  zh_CN: Oe,
  zh_TW: {
    addChild: "插入子節點",
    addParent: "插入父節點",
    addSibling: "插入同級節點",
    removeNode: "刪除節點",
    focus: "專注",
    cancelFocus: "取消專注",
    moveUp: "上移",
    moveDown: "下移",
    link: "連接",
    linkBidirectional: "雙向連接",
    clickTips: "請點擊目標節點",
    summary: "摘要"
  },
  en: {
    addChild: "Add child",
    addParent: "Add parent",
    addSibling: "Add sibling",
    removeNode: "Remove node",
    focus: "Focus Mode",
    cancelFocus: "Cancel Focus Mode",
    moveUp: "Move up",
    moveDown: "Move down",
    link: "Link",
    linkBidirectional: "Bidirectional Link",
    clickTips: "Please click the target node",
    summary: "Summary"
  },
  ru: {
    addChild: "Добавить дочерний элемент",
    addParent: "Добавить родительский элемент",
    addSibling: "Добавить на этом уровне",
    removeNode: "Удалить узел",
    focus: "Режим фокусировки",
    cancelFocus: "Отменить режим фокусировки",
    moveUp: "Поднять выше",
    moveDown: "Опустить ниже",
    link: "Ссылка",
    linkBidirectional: "Двунаправленная ссылка",
    clickTips: "Пожалуйста, нажмите на целевой узел",
    summary: "Описание"
  },
  ja: {
    addChild: "子ノードを追加する",
    addParent: "親ノードを追加します",
    addSibling: "兄弟ノードを追加する",
    removeNode: "ノードを削除",
    focus: "集中",
    cancelFocus: "集中解除",
    moveUp: "上へ移動",
    moveDown: "下へ移動",
    link: "コネクト",
    linkBidirectional: "双方向リンク",
    clickTips: "ターゲットノードをクリックしてください",
    summary: "概要"
  },
  pt: {
    addChild: "Adicionar item filho",
    addParent: "Adicionar item pai",
    addSibling: "Adicionar item irmao",
    removeNode: "Remover item",
    focus: "Modo Foco",
    cancelFocus: "Cancelar Modo Foco",
    moveUp: "Mover para cima",
    moveDown: "Mover para baixo",
    link: "Link",
    linkBidirectional: "Link bidirecional",
    clickTips: "Favor clicar no item alvo",
    summary: "Resumo"
  },
  it: {
    addChild: "Aggiungi figlio",
    addParent: "Aggiungi genitore",
    addSibling: "Aggiungi fratello",
    removeNode: "Rimuovi nodo",
    focus: "Modalità Focus",
    cancelFocus: "Annulla Modalità Focus",
    moveUp: "Sposta su",
    moveDown: "Sposta giù",
    link: "Collega",
    linkBidirectional: "Collegamento bidirezionale",
    clickTips: "Si prega di fare clic sul nodo di destinazione",
    summary: "Unisci nodi"
  },
  es: {
    addChild: "Agregar hijo",
    addParent: "Agregar padre",
    addSibling: "Agregar hermano",
    removeNode: "Eliminar nodo",
    focus: "Modo Enfoque",
    cancelFocus: "Cancelar Modo Enfoque",
    moveUp: "Mover hacia arriba",
    moveDown: "Mover hacia abajo",
    link: "Enlace",
    linkBidirectional: "Enlace bidireccional",
    clickTips: "Por favor haga clic en el nodo de destino",
    summary: "Resumen"
  },
  fr: {
    addChild: "Ajout enfant",
    addParent: "Ajout parent",
    addSibling: "Ajout voisin",
    removeNode: "Supprimer",
    focus: "Cibler",
    cancelFocus: "Retour",
    moveUp: "Monter",
    moveDown: "Descendre",
    link: "Lier",
    linkBidirectional: "Lien bidirectionnel",
    clickTips: "Cliquer sur le noeud cible",
    summary: "Annoter"
  },
  ko: {
    addChild: "?? ??",
    addParent: "?? ??",
    addSibling: "?? ??",
    removeNode: "?? ??",
    focus: "??? ??",
    cancelFocus: "??? ?? ??",
    moveUp: "?? ??",
    moveDown: "??? ??",
    link: "??",
    linkBidirectional: "??? ??",
    clickTips: "?? ??? ??????",
    summary: "??"
  }
};
function Mt(e, t) {
  t = t === !0 ? {
    focus: !0,
    link: !0
  } : t;
  const n = (x) => {
    const b = document.createElement("div");
    return b.innerText = x, b.className = "tips", b;
  }, o = (x, b, C) => {
    const N = document.createElement("li");
    return N.id = x, N.innerHTML = `<span>${ue(b)}</span><span ${C ? 'class="key"' : ""}>${ue(C)}</span>`, N;
  }, s = je[e.locale] ? e.locale : "en", i = je[s], l = o("cm-add_child", i.addChild, "Tab"), r = o("cm-add_parent", i.addParent, "Ctrl + Enter"), c = o("cm-add_sibling", i.addSibling, "Enter"), a = o("cm-remove_child", i.removeNode, "Delete"), h = o("cm-fucus", i.focus, ""), u = o("cm-unfucus", i.cancelFocus, ""), g = o("cm-up", i.moveUp, "PgUp"), v = o("cm-down", i.moveDown, "Pgdn"), m = o("cm-link", i.link, ""), p = o("cm-link-bidirectional", i.linkBidirectional, ""), d = o("cm-summary", i.summary, ""), f = document.createElement("ul");
  if (f.className = "menu-list", f.appendChild(l), f.appendChild(r), f.appendChild(c), f.appendChild(a), t.focus && (f.appendChild(h), f.appendChild(u)), f.appendChild(g), f.appendChild(v), f.appendChild(d), t.link && (f.appendChild(m), f.appendChild(p)), t && t.extend)
    for (let x = 0; x < t.extend.length; x++) {
      const b = t.extend[x], C = o(b.name, b.name, b.key || "");
      f.appendChild(C), C.onclick = (N) => {
        b.onclick(N);
      };
    }
  const y = document.createElement("div");
  y.className = "context-menu", y.appendChild(f), y.hidden = !0, e.container.append(y);
  let w = !0;
  const S = (x) => {
    const b = x.target;
    if (pe(b)) {
      b.parentElement.tagName === "ME-ROOT" ? w = !0 : w = !1, w ? (h.className = "disabled", g.className = "disabled", v.className = "disabled", r.className = "disabled", c.className = "disabled", a.className = "disabled") : (h.className = "", g.className = "", v.className = "", r.className = "", c.className = "", a.className = ""), y.hidden = !1, f.style.top = "", f.style.bottom = "", f.style.left = "", f.style.right = "";
      const C = f.getBoundingClientRect(), N = f.offsetHeight, L = f.offsetWidth, O = x.clientY - C.top, j = x.clientX - C.left;
      N + O > window.innerHeight ? (f.style.top = "", f.style.bottom = "0px") : (f.style.bottom = "", f.style.top = O + 15 + "px"), L + j > window.innerWidth ? (f.style.left = "", f.style.right = "0px") : (f.style.right = "", f.style.left = j + 10 + "px");
    }
  };
  e.bus.addListener("showContextMenu", S), y.onclick = (x) => {
    x.target === y && (y.hidden = !0);
  }, l.onclick = () => {
    e.addChild(), y.hidden = !0;
  }, r.onclick = () => {
    e.insertParent(), y.hidden = !0;
  }, c.onclick = () => {
    w || (e.insertSibling("after"), y.hidden = !0);
  }, a.onclick = () => {
    w || (e.removeNodes(e.currentNodes || []), y.hidden = !0);
  }, h.onclick = () => {
    w || (e.focusNode(e.currentNode), y.hidden = !0);
  }, u.onclick = () => {
    e.cancelFocus(), y.hidden = !0;
  }, g.onclick = () => {
    w || (e.moveUpNode(), y.hidden = !0);
  }, v.onclick = () => {
    w || (e.moveDownNode(), y.hidden = !0);
  };
  const E = (x) => {
    y.hidden = !0;
    const b = e.currentNode, C = n(i.clickTips);
    e.container.appendChild(C), e.map.addEventListener(
      "click",
      (N) => {
        N.preventDefault(), C.remove();
        const L = N.target;
        (L.parentElement.tagName === "ME-PARENT" || L.parentElement.tagName === "ME-ROOT") && e.createArrow(b, L, x);
      },
      {
        once: !0
      }
    );
  };
  return m.onclick = () => E(), p.onclick = () => E({ bidirectional: !0 }), d.onclick = () => {
    y.hidden = !0, e.createSummary(), e.unselectNodes(e.currentNodes);
  }, () => {
    l.onclick = null, r.onclick = null, c.onclick = null, a.onclick = null, h.onclick = null, u.onclick = null, g.onclick = null, v.onclick = null, m.onclick = null, d.onclick = null, y.onclick = null, e.container.oncontextmenu = null;
  };
}
const me = document, Dt = function(e, t) {
  if (!t)
    return ye(e), e;
  let n = e.querySelector(".insert-preview");
  const o = `insert-preview ${t} show`;
  return n || (n = me.createElement("div"), e.appendChild(n)), n.className = o, e;
}, ye = function(e) {
  if (!e) return;
  const t = e.querySelectorAll(".insert-preview");
  for (const n of t || [])
    n.remove();
}, He = function(e, t) {
  for (const n of t) {
    const o = n.parentElement.parentElement.contains(e);
    if (!(e && e.tagName === "ME-TPC" && e !== n && !o && e.nodeObj.parent)) return !1;
  }
  return !0;
}, Pt = function(e) {
  const t = document.createElement("div");
  return t.className = "mind-elixir-ghost", e.container.appendChild(t), t;
};
class $t {
  mind;
  isMoving = !1;
  interval = null;
  speed = 20;
  constructor(t) {
    this.mind = t;
  }
  move(t, n) {
    this.isMoving || (this.isMoving = !0, this.interval = setInterval(() => {
      this.mind.move(t * this.speed * this.mind.scaleVal, n * this.speed * this.mind.scaleVal);
    }, 100));
  }
  stop() {
    this.isMoving = !1, clearInterval(this.interval);
  }
}
function Ot(e) {
  let t = null, n = null;
  const o = Pt(e), s = new $t(e), i = (a) => {
    if (e.spacePressed) {
      a.preventDefault();
      return;
    }
    e.selection.cancel();
    const h = a.target;
    if (h?.tagName !== "ME-TPC") {
      a.preventDefault();
      return;
    }
    let u = e.currentNodes;
    u?.includes(h) || (e.selectNode(h), u = e.currentNodes), e.dragged = u, u.length > 1 ? o.innerHTML = u.length + "" : o.innerHTML = h.innerHTML;
    for (const g of u)
      g.parentElement.parentElement.style.opacity = "0.5";
    a.dataTransfer.setDragImage(o, 0, 0), a.dataTransfer.dropEffect = "move", e.dragMoveHelper.clear();
  }, l = (a) => {
    const { dragged: h } = e;
    if (!h) return;
    s.stop();
    for (const g of h)
      g.parentElement.parentElement.style.opacity = "1";
    const u = a.target;
    u.style.opacity = "", n && (ye(n), t === "before" ? e.moveNodeBefore(h, n) : t === "after" ? e.moveNodeAfter(h, n) : t === "in" && e.moveNodeIn(h, n), e.dragged = null, o.innerHTML = "");
  }, r = (a) => {
    a.preventDefault();
    const h = 12 * e.scaleVal, { dragged: u } = e;
    if (!u) return;
    const g = e.container.getBoundingClientRect();
    a.clientX < g.x + 50 ? s.move(1, 0) : a.clientX > g.x + g.width - 50 ? s.move(-1, 0) : a.clientY < g.y + 50 ? s.move(0, 1) : a.clientY > g.y + g.height - 50 ? s.move(0, -1) : s.stop(), ye(n);
    const v = me.elementFromPoint(a.clientX, a.clientY - h);
    if (He(v, u)) {
      n = v;
      const m = v.getBoundingClientRect(), p = m.y;
      a.clientY > p + m.height ? t = "after" : t = "in";
    } else {
      const m = me.elementFromPoint(a.clientX, a.clientY + h), p = m.getBoundingClientRect();
      if (He(m, u)) {
        n = m;
        const d = p.y;
        a.clientY < d ? t = "before" : t = "in";
      } else
        t = n = null;
    }
    n && Dt(n, t);
  };
  return Ce([
    { dom: e.map, evt: "dragstart", func: i },
    { dom: e.map, evt: "dragend", func: l },
    { dom: e.map, evt: "dragover", func: r }
  ]);
}
const jt = function(e) {
  return ["createSummary", "removeSummary", "finishEditSummary"].includes(e.name) ? {
    type: "summary",
    value: e.obj.id
  } : ["createArrow", "removeArrow", "finishEditArrowLabel"].includes(e.name) ? {
    type: "arrow",
    value: e.obj.id
  } : ["removeNodes", "copyNodes", "moveNodeBefore", "moveNodeAfter", "moveNodeIn"].includes(e.name) ? {
    type: "nodes",
    value: e.objs.map((t) => t.id)
  } : {
    type: "nodes",
    value: [e.obj.id]
  };
};
function Ht(e) {
  let t = [], n = -1, o = e.getData(), s = [];
  e.undo = function() {
    if (n > -1) {
      const c = t[n];
      o = c.prev, e.refresh(c.prev);
      try {
        c.currentTarget.type === "nodes" && (c.operation === "removeNodes" ? e.selectNodes(c.currentTarget.value.map((a) => this.findEle(a))) : e.selectNodes(c.currentSelected.map((a) => this.findEle(a))));
      } catch {
      } finally {
        n--;
      }
    }
  }, e.redo = function() {
    if (n < t.length - 1) {
      n++;
      const c = t[n];
      o = c.next, e.refresh(c.next);
      try {
        c.currentTarget.type === "nodes" && (c.operation === "removeNodes" ? e.selectNodes(c.currentSelected.map((a) => this.findEle(a))) : e.selectNodes(c.currentTarget.value.map((a) => this.findEle(a))));
      } catch {
      }
    }
  };
  const i = function(c) {
    if (c.name === "beginEdit") return;
    t = t.slice(0, n + 1);
    const a = e.getData(), h = {
      prev: o,
      operation: c.name,
      currentSelected: s.map((u) => u.id),
      currentTarget: jt(c),
      next: a
    };
    t.push(h), o = a, n = t.length - 1;
  }, l = function(c) {
    (c.metaKey || c.ctrlKey) && (c.shiftKey && c.key === "Z" || c.key === "y") ? e.redo() : (c.metaKey || c.ctrlKey) && c.key === "z" && e.undo();
  }, r = function() {
    s = e.currentNodes.map((c) => c.nodeObj);
  };
  return e.bus.addListener("operation", i), e.bus.addListener("selectNodes", r), e.container.addEventListener("keydown", l), () => {
    e.bus.removeListener("operation", i), e.bus.removeListener("selectNodes", r), e.container.removeEventListener("keydown", l);
  };
}
const Bt = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169394918" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2021" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M851.91168 328.45312c-59.97056 0-108.6208 48.47104-108.91264 108.36992l-137.92768 38.4a109.14304 109.14304 0 0 0-63.46752-46.58688l1.39264-137.11872c47.29344-11.86816 82.31936-54.66624 82.31936-105.64096 0-60.15488-48.76288-108.91776-108.91776-108.91776s-108.91776 48.76288-108.91776 108.91776c0 49.18784 32.60928 90.75712 77.38368 104.27392l-1.41312 138.87488a109.19936 109.19936 0 0 0-63.50336 48.55808l-138.93632-39.48544 0.01024-0.72704c0-60.15488-48.76288-108.91776-108.91776-108.91776s-108.91776 48.75776-108.91776 108.91776c0 60.15488 48.76288 108.91264 108.91776 108.91264 39.3984 0 73.91232-20.92032 93.03552-52.2496l139.19232 39.552-0.00512 0.2304c0 25.8304 9.00096 49.5616 24.02816 68.23424l-90.14272 132.63872a108.7488 108.7488 0 0 0-34.2528-5.504c-60.15488 0-108.91776 48.768-108.91776 108.91776 0 60.16 48.76288 108.91776 108.91776 108.91776 60.16 0 108.92288-48.75776 108.92288-108.91776 0-27.14624-9.9328-51.968-26.36288-71.04l89.04704-131.03104a108.544 108.544 0 0 0 37.6832 6.70208 108.672 108.672 0 0 0 36.48512-6.272l93.13792 132.57216a108.48256 108.48256 0 0 0-24.69888 69.0688c0 60.16 48.768 108.92288 108.91776 108.92288 60.16 0 108.91776-48.76288 108.91776-108.92288 0-60.14976-48.75776-108.91776-108.91776-108.91776a108.80512 108.80512 0 0 0-36.69504 6.3488l-93.07136-132.48a108.48768 108.48768 0 0 0 24.79616-72.22784l136.09984-37.888c18.99008 31.93856 53.84192 53.3504 93.69088 53.3504 60.16 0 108.92288-48.75776 108.92288-108.91264-0.00512-60.15488-48.77312-108.92288-108.92288-108.92288z" p-id="2022"></path></svg>', Rt = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169375313" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1775" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M639 463.30000001L639 285.1c0-36.90000001-26.4-68.5-61.3-68.5l-150.2 0c-1.5 0-3 0.1-4.5 0.3-10.2-38.7-45.5-67.3-87.5-67.3-50 0-90.5 40.5-90.5 90.5s40.5 90.5 90.5 90.5c42 0 77.3-28.6 87.5-67.39999999 1.4 0.3 2.9 0.4 4.5 0.39999999L577.7 263.6c6.8 0 14.3 8.9 14.3 21.49999999l0 427.00000001c0 12.7-7.40000001 21.5-14.30000001 21.5l-150.19999999 0c-1.5 0-3 0.2-4.5 0.4-10.2-38.8-45.5-67.3-87.5-67.3-50 0-90.5 40.5-90.5 90.4 0 49.9 40.5 90.6 90.5 90.59999999 42 0 77.3-28.6 87.5-67.39999999 1.4 0.2 2.9 0.4 4.49999999 0.4L577.7 780.7c34.80000001 0 61.3-31.6 61.3-68.50000001L639 510.3l79.1 0c10.4 38.5 45.49999999 67 87.4 67 50 0 90.5-40.5 90.5-90.5s-40.5-90.5-90.5-90.5c-41.79999999 0-77.00000001 28.4-87.4 67L639 463.30000001z" fill="currentColor" p-id="1776"></path></svg>', It = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169667709" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3037" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M385 560.69999999L385 738.9c0 36.90000001 26.4 68.5 61.3 68.5l150.2 0c1.5 0 3-0.1 4.5-0.3 10.2 38.7 45.5 67.3 87.5 67.3 50 0 90.5-40.5 90.5-90.5s-40.5-90.5-90.5-90.5c-42 0-77.3 28.6-87.5 67.39999999-1.4-0.3-2.9-0.4-4.5-0.39999999L446.3 760.4c-6.8 0-14.3-8.9-14.3-21.49999999l0-427.00000001c0-12.7 7.40000001-21.5 14.30000001-21.5l150.19999999 0c1.5 0 3-0.2 4.5-0.4 10.2 38.8 45.5 67.3 87.5 67.3 50 0 90.5-40.5 90.5-90.4 0-49.9-40.5-90.6-90.5-90.59999999-42 0-77.3 28.6-87.5 67.39999999-1.4-0.2-2.9-0.4-4.49999999-0.4L446.3 243.3c-34.80000001 0-61.3 31.6-61.3 68.50000001L385 513.7l-79.1 0c-10.4-38.5-45.49999999-67-87.4-67-50 0-90.5 40.5-90.5 90.5s40.5 90.5 90.5 90.5c41.79999999 0 77.00000001-28.4 87.4-67L385 560.69999999z" fill="currentColor" p-id="3038"></path></svg>', Ft = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169402629" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2170" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M639.328 416c8.032 0 16.096-3.008 22.304-9.056l202.624-197.184-0.8 143.808c-0.096 17.696 14.144 32.096 31.808 32.192 0.064 0 0.128 0 0.192 0 17.6 0 31.904-14.208 32-31.808l1.248-222.208c0-0.672-0.352-1.248-0.384-1.92 0.032-0.512 0.288-0.896 0.288-1.408 0.032-17.664-14.272-32-31.968-32.032L671.552 96l-0.032 0c-17.664 0-31.968 14.304-32 31.968C639.488 145.632 653.824 160 671.488 160l151.872 0.224-206.368 200.8c-12.672 12.32-12.928 32.608-0.64 45.248C622.656 412.736 630.976 416 639.328 416z" p-id="2171"></path><path d="M896.032 639.552 896.032 639.552c-17.696 0-32 14.304-32.032 31.968l-0.224 151.872-200.832-206.4c-12.32-12.64-32.576-12.96-45.248-0.64-12.672 12.352-12.928 32.608-0.64 45.248l197.184 202.624-143.808-0.8c-0.064 0-0.128 0-0.192 0-17.6 0-31.904 14.208-32 31.808-0.096 17.696 14.144 32.096 31.808 32.192l222.24 1.248c0.064 0 0.128 0 0.192 0 0.64 0 1.12-0.32 1.76-0.352 0.512 0.032 0.896 0.288 1.408 0.288l0.032 0c17.664 0 31.968-14.304 32-31.968L928 671.584C928.032 653.952 913.728 639.584 896.032 639.552z" p-id="2172"></path><path d="M209.76 159.744l143.808 0.8c0.064 0 0.128 0 0.192 0 17.6 0 31.904-14.208 32-31.808 0.096-17.696-14.144-32.096-31.808-32.192L131.68 95.328c-0.064 0-0.128 0-0.192 0-0.672 0-1.248 0.352-1.888 0.384-0.448 0-0.8-0.256-1.248-0.256 0 0-0.032 0-0.032 0-17.664 0-31.968 14.304-32 31.968L96 352.448c-0.032 17.664 14.272 32 31.968 32.032 0 0 0.032 0 0.032 0 17.664 0 31.968-14.304 32-31.968l0.224-151.936 200.832 206.4c6.272 6.464 14.624 9.696 22.944 9.696 8.032 0 16.096-3.008 22.304-9.056 12.672-12.32 12.96-32.608 0.64-45.248L209.76 159.744z" p-id="2173"></path><path d="M362.368 617.056l-202.624 197.184 0.8-143.808c0.096-17.696-14.144-32.096-31.808-32.192-0.064 0-0.128 0-0.192 0-17.6 0-31.904 14.208-32 31.808l-1.248 222.24c0 0.704 0.352 1.312 0.384 2.016 0 0.448-0.256 0.832-0.256 1.312-0.032 17.664 14.272 32 31.968 32.032L352.448 928c0 0 0.032 0 0.032 0 17.664 0 31.968-14.304 32-31.968s-14.272-32-31.968-32.032l-151.936-0.224 206.4-200.832c12.672-12.352 12.96-32.608 0.64-45.248S375.008 604.704 362.368 617.056z" p-id="2174"></path></svg>', Wt = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169573443" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2883" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M514.133333 488.533333m-106.666666 0a106.666667 106.666667 0 1 0 213.333333 0 106.666667 106.666667 0 1 0-213.333333 0Z" fill="currentColor" p-id="2884"></path><path d="M512 64C264.533333 64 64 264.533333 64 512c0 236.8 183.466667 428.8 416 445.866667v-134.4c-53.333333-59.733333-200.533333-230.4-200.533333-334.933334 0-130.133333 104.533333-234.666667 234.666666-234.666666s234.666667 104.533333 234.666667 234.666666c0 61.866667-49.066667 153.6-145.066667 270.933334l-59.733333 68.266666V960C776.533333 942.933333 960 748.8 960 512c0-247.466667-200.533333-448-448-448z" fill="currentColor" p-id="2885"></path></svg>', Kt = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169419447" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2480" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M863.328 482.56l-317.344-1.12L545.984 162.816c0-17.664-14.336-32-32-32s-32 14.336-32 32l0 318.4L159.616 480.064c-0.032 0-0.064 0-0.096 0-17.632 0-31.936 14.24-32 31.904C127.424 529.632 141.728 544 159.392 544.064l322.592 1.152 0 319.168c0 17.696 14.336 32 32 32s32-14.304 32-32l0-318.944 317.088 1.12c0.064 0 0.096 0 0.128 0 17.632 0 31.936-14.24 32-31.904C895.264 496.992 880.96 482.624 863.328 482.56z" p-id="2481"></path></svg>', Gt = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1750169426515" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2730" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M863.744 544 163.424 544c-17.664 0-32-14.336-32-32s14.336-32 32-32l700.32 0c17.696 0 32 14.336 32 32S881.44 544 863.744 544z" p-id="2731"></path></svg>', Yt = {
  side: Bt,
  left: Rt,
  right: It,
  full: Ft,
  living: Wt,
  zoomin: Kt,
  zoomout: Gt
}, F = (e, t) => {
  const n = document.createElement("span");
  return n.id = e, n.innerHTML = Yt[t], n;
};
function zt(e) {
  const t = document.createElement("div"), n = F("fullscreen", "full"), o = F("toCenter", "living"), s = F("zoomout", "zoomout"), i = F("zoomin", "zoomin"), l = document.createElement("span");
  return l.innerText = "100%", t.appendChild(n), t.appendChild(o), t.appendChild(s), t.appendChild(i), t.className = "mind-elixir-toolbar rb", n.onclick = () => {
    document.fullscreenElement === e.el ? document.exitFullscreen() : e.el.requestFullscreen();
  }, o.onclick = () => {
    e.toCenter();
  }, s.onclick = () => {
    e.scale(e.scaleVal - e.scaleSensitivity);
  }, i.onclick = () => {
    e.scale(e.scaleVal + e.scaleSensitivity);
  }, t;
}
function qt(e) {
  const t = document.createElement("div"), n = F("tbltl", "left"), o = F("tbltr", "right"), s = F("tblts", "side");
  return t.appendChild(n), t.appendChild(o), t.appendChild(s), t.className = "mind-elixir-toolbar lt", n.onclick = () => {
    e.initLeft();
  }, o.onclick = () => {
    e.initRight();
  }, s.onclick = () => {
    e.initSide();
  }, t;
}
function Vt(e) {
  e.container.append(zt(e)), e.container.append(qt(e));
}
class Xt {
  _listeners = /* @__PURE__ */ new Map();
  addEventListener(t, n) {
    const o = this._listeners.get(t) ?? /* @__PURE__ */ new Set();
    return this._listeners.set(t, o), o.add(n), this;
  }
  removeEventListener(t, n) {
    return this._listeners.get(t)?.delete(n), this;
  }
  dispatchEvent(t, ...n) {
    let o = !0;
    for (const s of this._listeners.get(t) ?? [])
      o = s(...n) !== !1 && o;
    return o;
  }
  unbindAllListeners() {
    this._listeners.clear();
  }
  // Let's also support on, off and emit like node
  on = this.addEventListener;
  off = this.removeEventListener;
  emit = this.dispatchEvent;
}
const Be = (e, t = "px") => typeof e == "number" ? e + t : e, H = ({ style: e }, t, n) => {
  if (typeof t == "object")
    for (const [o, s] of Object.entries(t))
      s !== void 0 && (e[o] = Be(s));
  else n !== void 0 && (e[t] = Be(n));
}, Re = (e = 0, t = 0, n = 0, o = 0) => {
  const s = { x: e, y: t, width: n, height: o, top: t, left: e, right: e + n, bottom: t + o };
  return { ...s, toJSON: () => JSON.stringify(s) };
}, Ut = (e) => {
  let t, n = -1, o = !1;
  return {
    next: (...s) => {
      t = s, o || (o = !0, n = requestAnimationFrame(() => {
        e(...t), o = !1;
      }));
    },
    cancel: () => {
      cancelAnimationFrame(n), o = !1;
    }
  };
}, Ie = (e, t, n = "touch") => {
  switch (n) {
    case "center": {
      const o = t.left + t.width / 2, s = t.top + t.height / 2;
      return o >= e.left && o <= e.right && s >= e.top && s <= e.bottom;
    }
    case "cover":
      return t.left >= e.left && t.top >= e.top && t.right <= e.right && t.bottom <= e.bottom;
    case "touch":
      return e.right >= t.left && e.left <= t.right && e.bottom >= t.top && e.top <= t.bottom;
  }
}, Jt = () => matchMedia("(hover: none), (pointer: coarse)").matches, Zt = () => "safari" in window, ve = (e) => Array.isArray(e) ? e : [e], tt = (e) => (t, n, o, s = {}) => {
  (t instanceof HTMLCollection || t instanceof NodeList) && (t = Array.from(t)), n = ve(n), t = ve(t);
  for (const i of t)
    if (i)
      for (const l of n)
        i[e](l, o, { capture: !1, ...s });
}, B = tt("addEventListener"), A = tt("removeEventListener"), ee = (e) => {
  const { clientX: t, clientY: n, target: o } = e.touches?.[0] ?? e;
  return { x: t, y: n, target: o };
}, K = (e, t = document) => ve(e).map((n) => typeof n == "string" ? Array.from(t.querySelectorAll(n)) : n instanceof Element ? n : null).flat().filter(Boolean), Qt = (e, t) => t.some((n) => typeof n == "number" ? e.button === n : typeof n == "object" ? n.button !== e.button ? !1 : n.modifiers.every((o) => {
  switch (o) {
    case "alt":
      return e.altKey;
    case "ctrl":
      return e.ctrlKey || e.metaKey;
    case "shift":
      return e.shiftKey;
  }
}) : !1), { abs: I, max: Fe, min: We, ceil: Ke } = Math, Ge = (e = []) => ({
  stored: e,
  selected: [],
  touched: [],
  changed: { added: [], removed: [] }
});
class en extends Xt {
  static version = "mind-elixir-fork";
  // Options
  _options;
  // Selection store
  _selection = Ge();
  // Area element and clipping element
  _area;
  _clippingElement;
  // Target container (element) and boundary (cached)
  _targetElement;
  _targetBoundary;
  _targetBoundaryScrolled = !0;
  _targetRect;
  _selectables = [];
  _latestElement;
  // Dynamically constructed area rect
  _areaLocation = { y1: 0, x2: 0, y2: 0, x1: 0 };
  _areaRect = Re();
  // If a single click is being performed, it's a single-click until the user dragged the mouse
  _singleClick = !0;
  _frame;
  // Required data for scrolling
  _scrollAvailable = !0;
  _scrollingActive = !1;
  _scrollSpeed = { x: 0, y: 0 };
  _scrollDelta = { x: 0, y: 0 };
  // Required for keydown scrolling
  _lastMousePosition = { x: 0, y: 0 };
  constructor(t) {
    super(), this._options = {
      selectionAreaClass: "selection-area",
      selectionContainerClass: void 0,
      selectables: [],
      document: window.document,
      startAreas: ["html"],
      boundaries: ["html"],
      container: "body",
      mindElixirInstance: void 0,
      // 添加默认值
      ...t,
      behaviour: {
        overlap: "invert",
        intersect: "touch",
        triggers: [0],
        ...t.behaviour,
        startThreshold: t.behaviour?.startThreshold ? typeof t.behaviour.startThreshold == "number" ? t.behaviour.startThreshold : { x: 10, y: 10, ...t.behaviour.startThreshold } : { x: 10, y: 10 },
        scrolling: {
          speedDivider: 10,
          manualSpeed: 750,
          ...t.behaviour?.scrolling,
          startScrollMargins: {
            x: 0,
            y: 0,
            ...t.behaviour?.scrolling?.startScrollMargins
          }
        }
      },
      features: {
        range: !0,
        touch: !0,
        deselectOnBlur: !1,
        ...t.features,
        singleTap: {
          allow: !0,
          intersect: "native",
          ...t.features?.singleTap
        }
      }
    };
    for (const i of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))
      typeof this[i] == "function" && (this[i] = this[i].bind(this));
    const { document: n, selectionAreaClass: o, selectionContainerClass: s } = this._options;
    this._area = n.createElement("div"), this._clippingElement = n.createElement("div"), this._clippingElement.appendChild(this._area), this._area.classList.add(o), s && this._clippingElement.classList.add(s), H(this._area, {
      willChange: "top, left, bottom, right, width, height",
      top: 0,
      left: 0,
      position: "fixed"
    }), H(this._clippingElement, {
      overflow: "hidden",
      position: "fixed",
      transform: "translate3d(0, 0, 0)",
      // https://stackoverflow.com/a/38268846
      pointerEvents: "none",
      zIndex: "1"
    }), this._frame = Ut((i) => {
      this._recalculateSelectionAreaRect(), this._updateElementSelection(), this._emitEvent("move", i), this._redrawSelectionArea();
    }), this.enable();
  }
  _toggleStartEvents(t = !0) {
    const { document: n, features: o } = this._options, s = t ? B : A;
    s(n, "mousedown", this._onTapStart), o.touch && s(n, "touchstart", this._onTapStart, { passive: !1 });
  }
  _onTapStart(t, n = !1) {
    const { x: o, y: s, target: i } = ee(t), { document: l, startAreas: r, boundaries: c, features: a, behaviour: h } = this._options, u = i.getBoundingClientRect();
    if (t instanceof MouseEvent && !Qt(t, h.triggers))
      return;
    const g = K(r, l), v = K(c, l);
    this._targetElement = v.find((f) => Ie(f.getBoundingClientRect(), u));
    const m = t.composedPath(), p = g.find((f) => m.includes(f));
    if (this._targetBoundary = v.find((f) => m.includes(f)), !this._targetElement || !p || !this._targetBoundary || !n && this._emitEvent("beforestart", t) === !1)
      return;
    this._areaLocation = { x1: o, y1: s, x2: 0, y2: 0 };
    const d = l.scrollingElement ?? l.body;
    this._scrollDelta = { x: d.scrollLeft, y: d.scrollTop }, this._singleClick = !0, this.clearSelection(!1, !0), B(l, ["touchmove", "mousemove"], this._delayedTapMove, { passive: !1 }), B(l, ["mouseup", "touchcancel", "touchend"], this._onTapStop), B(l, "scroll", this._onScroll), a.deselectOnBlur && (this._targetBoundaryScrolled = !1, B(this._targetBoundary, "scroll", this._onStartAreaScroll));
  }
  _onSingleTap(t) {
    const {
      singleTap: { intersect: n },
      range: o
    } = this._options.features, s = ee(t);
    let i;
    if (n === "native")
      i = s.target;
    else if (n === "touch") {
      this.resolveSelectables();
      const { x: r, y: c } = s;
      i = this._selectables.find((a) => {
        const { right: h, left: u, top: g, bottom: v } = a.getBoundingClientRect();
        return r < h && r > u && c < v && c > g;
      });
    }
    if (!i)
      return;
    for (this.resolveSelectables(); !this._selectables.includes(i); )
      if (i.parentElement)
        i = i.parentElement;
      else {
        this._targetBoundaryScrolled || this.clearSelection();
        return;
      }
    const { stored: l } = this._selection;
    if (this._emitEvent("start", t), t.shiftKey && o && this._latestElement) {
      const r = this._latestElement, [c, a] = r.compareDocumentPosition(i) & 4 ? [i, r] : [r, i], h = [
        ...this._selectables.filter((u) => u.compareDocumentPosition(c) & 4 && u.compareDocumentPosition(a) & 2),
        c,
        a
      ];
      this.select(h), this._latestElement = r;
    } else l.includes(i) && (l.length === 1 || t.ctrlKey || l.every((r) => this._selection.stored.includes(r))) ? this.deselect(i) : (this.select(i), this._latestElement = i);
  }
  _delayedTapMove(t) {
    const {
      container: n,
      document: o,
      behaviour: { startThreshold: s }
    } = this._options, { x1: i, y1: l } = this._areaLocation, { x: r, y: c } = ee(t);
    if (
      // Single number for both coordinates
      typeof s == "number" && I(r + c - (i + l)) >= s || // Different x and y threshold
      typeof s == "object" && I(r - i) >= s.x || I(c - l) >= s.y
    ) {
      if (A(o, ["mousemove", "touchmove"], this._delayedTapMove, { passive: !1 }), this._emitEvent("beforedrag", t) === !1) {
        A(o, ["mouseup", "touchcancel", "touchend"], this._onTapStop);
        return;
      }
      B(o, ["mousemove", "touchmove"], this._onTapMove, { passive: !1 }), H(this._area, "display", "block"), K(n, o)[0].appendChild(this._clippingElement), this.resolveSelectables(), this._singleClick = !1, this._targetRect = this._targetElement.getBoundingClientRect(), this._scrollAvailable = this._targetElement.scrollHeight !== this._targetElement.clientHeight || this._targetElement.scrollWidth !== this._targetElement.clientWidth, this._scrollAvailable && (B(this._targetElement, "wheel", this._wheelScroll, { passive: !1 }), B(this._options.document, "keydown", this._keyboardScroll, { passive: !1 }), this._selectables = this._selectables.filter((a) => this._targetElement.contains(a))), this._setupSelectionArea(), this._emitEvent("start", t), this._onTapMove(t);
    }
    this._handleMoveEvent(t);
  }
  _setupSelectionArea() {
    const { _clippingElement: t, _targetElement: n, _area: o } = this, s = this._targetRect = n.getBoundingClientRect();
    this._scrollAvailable ? (H(t, {
      top: s.top,
      left: s.left,
      width: s.width,
      height: s.height
    }), H(o, {
      marginTop: -s.top,
      marginLeft: -s.left
    })) : (H(t, {
      top: 0,
      left: 0,
      width: "100%",
      height: "100%"
    }), H(o, {
      marginTop: 0,
      marginLeft: 0
    }));
  }
  _onTapMove(t) {
    const { _scrollSpeed: n, _areaLocation: o, _options: s, _frame: i } = this, { speedDivider: l } = s.behaviour.scrolling;
    this._targetElement;
    const { x: r, y: c } = ee(t);
    if (o.x2 = r, o.y2 = c, this._lastMousePosition.x = r, this._lastMousePosition.y = c, this._scrollAvailable && !this._scrollingActive && (n.y || n.x)) {
      this._scrollingActive = !0;
      const a = () => {
        if (!n.x && !n.y) {
          this._scrollingActive = !1;
          return;
        }
        const h = this._options.mindElixirInstance;
        if (h && h.move) {
          const u = n.x ? Ke(n.x / l) : 0, g = n.y ? Ke(n.y / l) : 0;
          (u || g) && (h.move(-u, -g), o.x1 -= u, o.y1 -= g);
        }
        i.next(t), requestAnimationFrame(a);
      };
      requestAnimationFrame(a);
    } else
      i.next(t);
    this._handleMoveEvent(t);
  }
  _handleMoveEvent(t) {
    const { features: n } = this._options;
    (n.touch && Jt() || this._scrollAvailable && Zt()) && t.preventDefault();
  }
  _onScroll() {
    const {
      _scrollDelta: t,
      _options: { document: n }
    } = this, { scrollTop: o, scrollLeft: s } = n.scrollingElement ?? n.body;
    this._areaLocation.x1 += t.x - s, this._areaLocation.y1 += t.y - o, t.x = s, t.y = o, this._setupSelectionArea(), this._frame.next(null);
  }
  _onStartAreaScroll() {
    this._targetBoundaryScrolled = !0, A(this._targetElement, "scroll", this._onStartAreaScroll);
  }
  _wheelScroll(t) {
    const { manualSpeed: n } = this._options.behaviour.scrolling, o = t.deltaY ? t.deltaY > 0 ? 1 : -1 : 0, s = t.deltaX ? t.deltaX > 0 ? 1 : -1 : 0;
    this._scrollSpeed.y += o * n, this._scrollSpeed.x += s * n, this._onTapMove(t), t.preventDefault();
  }
  _keyboardScroll(t) {
    const { manualSpeed: n } = this._options.behaviour.scrolling, o = t.key === "ArrowLeft" ? -1 : t.key === "ArrowRight" ? 1 : 0, s = t.key === "ArrowUp" ? -1 : t.key === "ArrowDown" ? 1 : 0;
    this._scrollSpeed.x += Math.sign(o) * n, this._scrollSpeed.y += Math.sign(s) * n, t.preventDefault(), this._onTapMove({
      clientX: this._lastMousePosition.x,
      clientY: this._lastMousePosition.y,
      preventDefault: () => {
      }
    });
  }
  _recalculateSelectionAreaRect() {
    const { _scrollSpeed: t, _areaLocation: n, _targetElement: o, _options: s } = this, i = this._targetRect, { x1: l, y1: r } = n;
    let { x2: c, y2: a } = n;
    const {
      behaviour: {
        scrolling: { startScrollMargins: h }
      }
    } = s;
    c < i.left + h.x ? (t.x = -I(i.left - c + h.x), c = c < i.left ? i.left : c) : c > i.right - h.x ? (t.x = I(i.left + i.width - c - h.x), c = c > i.right ? i.right : c) : t.x = 0, a < i.top + h.y ? (t.y = -I(i.top - a + h.y), a = a < i.top ? i.top : a) : a > i.bottom - h.y ? (t.y = I(i.top + i.height - a - h.y), a = a > i.bottom ? i.bottom : a) : t.y = 0;
    const u = We(l, c), g = We(r, a), v = Fe(l, c), m = Fe(r, a);
    this._areaRect = Re(u, g, v - u, m - g);
  }
  _redrawSelectionArea() {
    const { x: t, y: n, width: o, height: s } = this._areaRect, { style: i } = this._area;
    i.left = `${t}px`, i.top = `${n}px`, i.width = `${o}px`, i.height = `${s}px`;
  }
  _onTapStop(t, n) {
    const { document: o, features: s } = this._options, { _singleClick: i } = this;
    A(this._targetElement, "scroll", this._onStartAreaScroll), A(o, ["mousemove", "touchmove"], this._delayedTapMove), A(o, ["touchmove", "mousemove"], this._onTapMove), A(o, ["mouseup", "touchcancel", "touchend"], this._onTapStop), A(o, "scroll", this._onScroll), this._keepSelection(), t && i && s.singleTap.allow ? this._onSingleTap(t) : !i && !n && (this._updateElementSelection(), this._emitEvent("stop", t)), this._scrollSpeed.x = 0, this._scrollSpeed.y = 0, A(this._targetElement, "wheel", this._wheelScroll, { passive: !0 }), A(this._options.document, "keydown", this._keyboardScroll, { passive: !0 }), this._clippingElement.remove(), this._frame?.cancel(), H(this._area, "display", "none");
  }
  _updateElementSelection() {
    const { _selectables: t, _options: n, _selection: o, _areaRect: s } = this, { stored: i, selected: l, touched: r } = o, { intersect: c, overlap: a } = n.behaviour, h = a === "invert", u = [], g = [], v = [];
    for (let p = 0; p < t.length; p++) {
      const d = t[p];
      if (Ie(s, d.getBoundingClientRect(), c)) {
        if (l.includes(d))
          i.includes(d) && !r.includes(d) && r.push(d);
        else if (h && i.includes(d)) {
          v.push(d);
          continue;
        } else
          g.push(d);
        u.push(d);
      }
    }
    h && g.push(...i.filter((p) => !l.includes(p)));
    const m = a === "keep";
    for (let p = 0; p < l.length; p++) {
      const d = l[p];
      !u.includes(d) && !// Check if the user wants to keep previously selected elements, e.g.,
      // not make them part of the current selection as soon as they're touched.
      (m && i.includes(d)) && v.push(d);
    }
    o.selected = u, o.changed = { added: g, removed: v }, this._latestElement = void 0;
  }
  _emitEvent(t, n) {
    return this.emit(t, {
      event: n,
      store: this._selection,
      selection: this
    });
  }
  _keepSelection() {
    const { _options: t, _selection: n } = this, { selected: o, changed: s, touched: i, stored: l } = n, r = o.filter((c) => !l.includes(c));
    switch (t.behaviour.overlap) {
      case "drop": {
        n.stored = [
          ...r,
          ...l.filter((c) => !i.includes(c))
          // Elements not touched
        ];
        break;
      }
      case "invert": {
        n.stored = [
          ...r,
          ...l.filter((c) => !s.removed.includes(c))
          // Elements not removed from selection
        ];
        break;
      }
      case "keep": {
        n.stored = [
          ...l,
          ...o.filter((c) => !l.includes(c))
          // Newly added
        ];
        break;
      }
    }
  }
  /**
   * Manually triggers the start of a selection
   * @param evt A MouseEvent / TouchEvent-like object
   * @param silent If beforestart should be fired
   */
  trigger(t, n = !0) {
    this._onTapStart(t, n);
  }
  /**
   * Can be used if during a selection elements have been added
   * Will update everything that can be selected
   */
  resolveSelectables() {
    this._selectables = K(this._options.selectables, this._options.document);
  }
  /**
   * Same as deselecting, but for all elements currently selected
   * @param includeStored If the store should also get cleared
   * @param quiet If move / stop events should be fired
   */
  clearSelection(t = !0, n = !1) {
    const { selected: o, stored: s, changed: i } = this._selection;
    i.added = [], i.removed.push(...o, ...t ? s : []), n || (this._emitEvent("move", null), this._emitEvent("stop", null)), this._selection = Ge(t ? [] : s);
  }
  /**
   * @returns {Array} Selected elements
   */
  getSelection() {
    return this._selection.stored;
  }
  /**
   * @returns {HTMLElement} The selection area element
   */
  getSelectionArea() {
    return this._area;
  }
  /**
   * @returns {Element[]} Available selectable elements for current selection
   */
  getSelectables() {
    return this._selectables;
  }
  /**
   * Set the location of the selection area
   * @param location A partial AreaLocation object
   */
  setAreaLocation(t) {
    Object.assign(this._areaLocation, t), this._redrawSelectionArea();
  }
  /**
   * @returns {AreaLocation} The current location of the selection area
   */
  getAreaLocation() {
    return this._areaLocation;
  }
  /**
   * Cancel the current selection process, pass true to fire a stop event after cancel
   * @param keepEvent If a stop event should be fired
   */
  cancel(t = !1) {
    this._onTapStop(null, !t);
  }
  /**
   * Unbinds all events and removes the area-element.
   */
  destroy() {
    this.cancel(), this.disable(), this._clippingElement.remove(), super.unbindAllListeners();
  }
  /**
   * Enable selecting elements
   */
  enable = this._toggleStartEvents;
  /**
   * Disable selecting elements
   */
  disable = this._toggleStartEvents.bind(this, !1);
  /**
   * Adds elements to the selection
   * @param query CSS Query, can be an array of queries
   * @param quiet If this should not trigger the move event
   */
  select(t, n = !1) {
    const { changed: o, selected: s, stored: i } = this._selection, l = K(t, this._options.document).filter((r) => !s.includes(r) && !i.includes(r));
    return i.push(...l), s.push(...l), o.added.push(...l), o.removed = [], this._latestElement = void 0, n || (this._emitEvent("move", null), this._emitEvent("stop", null)), l;
  }
  /**
   * Removes a particular element from the selection
   * @param query CSS Query, can be an array of queries
   * @param quiet If this should not trigger the move event
   */
  deselect(t, n = !1) {
    const { selected: o, stored: s, changed: i } = this._selection, l = K(t, this._options.document).filter((r) => o.includes(r) || s.includes(r));
    this._selection.stored = s.filter((r) => !l.includes(r)), this._selection.selected = o.filter((r) => !l.includes(r)), this._selection.changed.added = [], this._selection.changed.removed.push(...l.filter((r) => !i.removed.includes(r))), this._latestElement = void 0, n || (this._emitEvent("move", null), this._emitEvent("stop", null));
  }
}
function tn(e) {
  const t = e.mouseSelectionButton === 2 ? [2] : [0], n = new en({
    selectables: [".map-container me-tpc"],
    boundaries: [e.container],
    container: e.selectionContainer,
    mindElixirInstance: e,
    // 传递 MindElixir 实例
    features: {
      // deselectOnBlur: true,
      touch: !1
    },
    behaviour: {
      triggers: t,
      // Scroll configuration.
      scrolling: {
        // On scrollable areas the number on px per frame is devided by this amount.
        // Default is 10 to provide a enjoyable scroll experience.
        speedDivider: 10,
        startScrollMargins: { x: 50, y: 50 }
      }
    }
  }).on("beforestart", ({ event: o }) => {
    if (e.spacePressed) return !1;
    const s = o.target;
    if (s.id === "input-box" || s.className === "circle" || e.container.querySelector(".context-menu")?.contains(s))
      return !1;
    if (!o.ctrlKey && !o.metaKey) {
      if (s.tagName === "ME-TPC" && s.classList.contains("selected"))
        return !1;
      e.clearSelection();
    }
    const i = n.getSelectionArea();
    return i.style.background = "#4f90f22d", i.style.border = "1px solid #4f90f2", i.parentElement && (i.parentElement.style.zIndex = "9999"), !0;
  }).on(
    "move",
    ({
      store: {
        changed: { added: o, removed: s }
      }
    }) => {
      if (o.length > 0 || s.length > 0, o.length > 0) {
        for (const i of o)
          i.className = "selected";
        e.currentNodes = [...e.currentNodes, ...o], e.bus.fire(
          "selectNodes",
          o.map((i) => i.nodeObj)
        );
      }
      if (s.length > 0) {
        for (const i of s)
          i.classList.remove("selected");
        e.currentNodes = e.currentNodes.filter((i) => !s?.includes(i)), e.bus.fire(
          "unselectNodes",
          s.map((i) => i.nodeObj)
        );
      }
    }
  );
  e.selection = n;
}
const nn = function(e, t = !0) {
  this.theme = e;
  const o = {
    ...(e.type === "dark" ? we : be).cssVar,
    ...e.cssVar
  }, s = Object.keys(o);
  for (let i = 0; i < s.length; i++) {
    const l = s[i];
    this.container.style.setProperty(l, o[l]);
  }
  t && this.refresh();
}, V = (e) => {
  const t = e.parent?.children, n = t?.indexOf(e) ?? 0;
  return { siblings: t, index: n };
};
function on(e) {
  const { siblings: t, index: n } = V(e);
  if (t === void 0) return;
  const o = t[n];
  n === 0 ? (t[n] = t[t.length - 1], t[t.length - 1] = o) : (t[n] = t[n - 1], t[n - 1] = o);
}
function sn(e) {
  const { siblings: t, index: n } = V(e);
  if (t === void 0) return;
  const o = t[n];
  n === t.length - 1 ? (t[n] = t[0], t[0] = o) : (t[n] = t[n + 1], t[n + 1] = o);
}
function nt(e) {
  const { siblings: t, index: n } = V(e);
  return t === void 0 ? 0 : (t.splice(n, 1), t.length);
}
function rn(e, t, n) {
  const { siblings: o, index: s } = V(n);
  o !== void 0 && (t === "before" ? o.splice(s, 0, e) : o.splice(s + 1, 0, e));
}
function ln(e, t) {
  const { siblings: n, index: o } = V(e);
  n !== void 0 && (n[o] = t, t.children = [e]);
}
function ot(e, t, n) {
  if (nt(t), n.parent?.parent || (t.direction = n.direction), e === "in")
    n.children ? n.children.push(t) : n.children = [t];
  else {
    t.direction !== void 0 && (t.direction = n.direction);
    const { siblings: o, index: s } = V(n);
    if (o === void 0) return;
    e === "before" ? o.splice(s, 0, t) : o.splice(s + 1, 0, t);
  }
}
const cn = function({ map: e, direction: t }, n) {
  if (t === 0)
    return 0;
  if (t === 1)
    return 1;
  if (t === 2) {
    const o = e.querySelector(".lhs")?.childElementCount || 0, s = e.querySelector(".rhs")?.childElementCount || 0;
    return o <= s ? (n.direction = 0, 0) : (n.direction = 1, 1);
  }
}, st = function(e, t, n) {
  const o = n.children[0].children[0], s = t.parentElement;
  if (s.tagName === "ME-PARENT") {
    if (J(o), s.children[1])
      s.nextSibling.appendChild(n);
    else {
      const i = e.createChildren([n]);
      s.appendChild(Ne(!0)), s.insertAdjacentElement("afterend", i);
    }
    e.linkDiv(n.offsetParent);
  } else s.tagName === "ME-ROOT" && (cn(e, o.nodeObj) === 0 ? e.container.querySelector(".lhs")?.appendChild(n) : e.container.querySelector(".rhs")?.appendChild(n), e.linkDiv());
}, an = function(e, t) {
  const n = e.parentNode;
  if (t === 0) {
    const o = n.parentNode.parentNode;
    o.tagName !== "ME-MAIN" && (o.previousSibling.children[1].remove(), o.remove());
  }
  n.parentNode.remove();
}, it = {
  before: "beforebegin",
  after: "afterend"
}, J = function(e) {
  const n = e.parentElement.parentElement.lastElementChild;
  n?.tagName === "svg" && n?.remove();
}, dn = function(e, t) {
  const n = e.nodeObj, o = Ee(n);
  o.style && t.style && (t.style = Object.assign(o.style, t.style));
  const s = Object.assign(n, t);
  Se.call(this, e, s), this.linkDiv(), this.bus.fire("operation", {
    name: "reshapeNode",
    obj: s,
    origin: o
  });
}, ke = function(e, t, n) {
  if (!t) return null;
  const o = t.nodeObj;
  o.expanded === !1 && (e.expandNode(t, !0), t = e.findEle(o.id));
  const s = n || e.generateNewObj();
  o.children ? o.children.push(s) : o.children = [s], R(e.nodeData);
  const { grp: i, top: l } = e.createWrapper(s);
  return st(e, t, i), { newTop: l, newNodeObj: s };
}, hn = function(e, t, n) {
  const o = t || this.currentNode;
  if (!o) return;
  const s = o.nodeObj;
  if (s.parent) {
    if (!s.parent?.parent && this.direction === 2) {
      const a = this.map.querySelector(".lhs")?.childElementCount || 0, h = this.map.querySelector(".rhs")?.childElementCount || 0;
      if (!a || !h) {
        this.addChild(this.findEle(s.parent.id), n);
        return;
      }
    }
  } else {
    this.addChild();
    return;
  }
  const i = n || this.generateNewObj();
  if (!s.parent?.parent) {
    const a = o.closest("me-main").className === D.LHS ? 0 : 1;
    i.direction = a;
  }
  rn(i, e, s), R(this.nodeData);
  const l = o.parentElement, { grp: r, top: c } = this.createWrapper(i);
  l.parentElement.insertAdjacentElement(it[e], r), this.linkDiv(r.offsetParent), n || this.editTopic(c.firstChild), this.bus.fire("operation", {
    name: "insertSibling",
    type: e,
    obj: i
  }), this.selectNode(c.firstChild, !0);
}, fn = function(e, t) {
  const n = e || this.currentNode;
  if (!n) return;
  J(n);
  const o = n.nodeObj;
  if (!o.parent)
    return;
  const s = t || this.generateNewObj();
  ln(o, s), R(this.nodeData);
  const i = n.parentElement.parentElement, { grp: l, top: r } = this.createWrapper(s, !0);
  r.appendChild(Ne(!0)), i.insertAdjacentElement("afterend", l);
  const c = this.createChildren([i]);
  r.insertAdjacentElement("afterend", c), this.linkDiv(), t || this.editTopic(r.firstChild), this.selectNode(r.firstChild, !0), this.bus.fire("operation", {
    name: "insertParent",
    obj: s
  });
}, un = function(e, t) {
  const n = e || this.currentNode;
  if (!n) return;
  const o = ke(this, n, t);
  if (!o) return;
  const { newTop: s, newNodeObj: i } = o;
  this.bus.fire("operation", {
    name: "addChild",
    obj: i
  }), t || this.editTopic(s.firstChild), this.selectNode(s.firstChild, !0);
}, pn = function(e, t) {
  const n = Ee(e.nodeObj);
  xe(n);
  const o = ke(this, t, n);
  if (!o) return;
  const { newNodeObj: s } = o;
  this.selectNode(this.findEle(s.id)), this.bus.fire("operation", {
    name: "copyNode",
    obj: s
  });
}, gn = function(e, t) {
  e = ae(e);
  const n = [];
  for (let o = 0; o < e.length; o++) {
    const s = e[o], i = Ee(s.nodeObj);
    xe(i);
    const l = ke(this, t, i);
    if (!l) return;
    const { newNodeObj: r } = l;
    n.push(r);
  }
  this.unselectNodes(this.currentNodes), this.selectNodes(n.map((o) => this.findEle(o.id))), this.bus.fire("operation", {
    name: "copyNodes",
    objs: n
  });
}, mn = function(e) {
  const t = e || this.currentNode;
  if (!t) return;
  const n = t.nodeObj;
  on(n);
  const o = t.parentNode.parentNode;
  o.parentNode.insertBefore(o, o.previousSibling), this.linkDiv(), this.bus.fire("operation", {
    name: "moveUpNode",
    obj: n
  });
}, yn = function(e) {
  const t = e || this.currentNode;
  if (!t) return;
  const n = t.nodeObj;
  sn(n);
  const o = t.parentNode.parentNode;
  o.nextSibling ? o.nextSibling.insertAdjacentElement("afterend", o) : o.parentNode.prepend(o), this.linkDiv(), this.bus.fire("operation", {
    name: "moveDownNode",
    obj: n
  });
}, vn = function(e) {
  if (e.length === 0) return;
  e = ae(e);
  for (const n of e) {
    const o = n.nodeObj, s = nt(o);
    an(n, s);
  }
  const t = e[e.length - 1];
  this.selectNode(this.findEle(t.nodeObj.parent.id)), this.linkDiv(), this.bus.fire("operation", {
    name: "removeNodes",
    objs: e.map((n) => n.nodeObj)
  });
}, bn = function(e, t) {
  e = ae(e);
  const n = t.nodeObj;
  n.expanded === !1 && (this.expandNode(t, !0), t = this.findEle(n.id));
  for (const o of e) {
    const s = o.nodeObj;
    ot("in", s, n), R(this.nodeData);
    const i = o.parentElement;
    st(this, t, i.parentElement);
  }
  this.linkDiv(), this.bus.fire("operation", {
    name: "moveNodeIn",
    objs: e.map((o) => o.nodeObj),
    toObj: n
  });
}, rt = (e, t, n, o) => {
  e = ae(e), t === "after" && (e = e.reverse());
  const s = n.nodeObj, i = [];
  for (const l of e) {
    const r = l.nodeObj;
    ot(t, r, s), R(o.nodeData), J(l);
    const c = l.parentElement.parentNode;
    i.includes(c.parentElement) || i.push(c.parentElement), n.parentElement.parentNode.insertAdjacentElement(it[t], c);
  }
  for (const l of i)
    l.childElementCount === 0 && l.tagName !== "ME-MAIN" && (l.previousSibling.children[1].remove(), l.remove());
  o.linkDiv(), o.bus.fire("operation", {
    name: t === "before" ? "moveNodeBefore" : "moveNodeAfter",
    objs: e.map((l) => l.nodeObj),
    toObj: s
  });
}, wn = function(e, t) {
  rt(e, "before", t, this);
}, xn = function(e, t) {
  rt(e, "after", t, this);
}, En = function(e) {
  const t = e || this.currentNode;
  t && (t.nodeObj.dangerouslySetInnerHTML || this.editTopic(t));
}, Cn = function(e, t) {
  e.text.textContent = t, e.nodeObj.topic = t, this.linkDiv();
}, lt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addChild: un,
  beginEdit: En,
  copyNode: pn,
  copyNodes: gn,
  insertParent: fn,
  insertSibling: hn,
  moveDownNode: yn,
  moveNodeAfter: xn,
  moveNodeBefore: wn,
  moveNodeIn: bn,
  moveUpNode: mn,
  removeNodes: vn,
  reshapeNode: dn,
  rmSubline: J,
  setNodeTopic: Cn
}, Symbol.toStringTag, { value: "Module" }));
function Sn(e) {
  return {
    nodeData: e.isFocusMode ? e.nodeDataBackup : e.nodeData,
    arrows: e.arrows,
    summaries: e.summaries,
    direction: e.direction,
    theme: e.theme
  };
}
const Nn = function(e) {
  const t = this.container, n = e.getBoundingClientRect(), o = t.getBoundingClientRect();
  if (n.top > o.bottom || n.bottom < o.top || n.left > o.right || n.right < o.left) {
    const i = n.left + n.width / 2, l = n.top + n.height / 2, r = o.left + o.width / 2, c = o.top + o.height / 2, a = i - r, h = l - c;
    this.move(-a, -h, !0);
  }
}, kn = function(e, t, n) {
  this.clearSelection(), this.scrollIntoView(e), this.selection.select(e), t && this.bus.fire("selectNewNode", e.nodeObj);
}, _n = function(e) {
  this.selection.select(e);
}, Tn = function(e) {
  this.selection.deselect(e);
}, Ln = function() {
  this.unselectNodes(this.currentNodes), this.unselectSummary(), this.unselectArrow();
}, An = function() {
  const e = Sn(this);
  return JSON.stringify(e, (t, n) => {
    if (!(t === "parent" && typeof n != "string"))
      return n;
  });
}, Mn = function() {
  return JSON.parse(this.getDataString());
}, Dn = function() {
  this.editable = !0;
}, Pn = function() {
  this.editable = !1;
}, $n = function(e, t = { x: 0, y: 0 }) {
  if (e < this.scaleMin || e > this.scaleMax) return;
  const n = this.container.getBoundingClientRect(), o = t.x ? t.x - n.left - n.width / 2 : 0, s = t.y ? t.y - n.top - n.height / 2 : 0, { dx: i, dy: l } = ct(this), r = this.map.style.transform, { x: c, y: a } = Xe(r), h = c - i, u = a - l, g = this.scaleVal, v = (-o + h) * (1 - e / g), m = (-s + u) * (1 - e / g);
  this.map.style.transform = `translate(${c - v}px, ${a - m}px) scale(${e})`, this.scaleVal = e, this.bus.fire("scale", e);
}, On = function() {
  const e = this.nodes.offsetHeight / this.container.offsetHeight, t = this.nodes.offsetWidth / this.container.offsetWidth, n = 1 / Math.max(1, Math.max(e, t));
  this.scaleVal = n, this.map.style.transform = "scale(" + n + ")", this.bus.fire("scale", n);
}, jn = function(e, t, n = !1) {
  const { map: o, scaleVal: s, bus: i } = this, l = o.style.transform;
  let { x: r, y: c } = Xe(l);
  r += e, c += t, n && (o.style.transition = "transform 0.3s", setTimeout(() => {
    o.style.transition = "none";
  }, 300)), o.style.transform = `translate(${r}px, ${c}px) scale(${s})`, i.fire("move", { dx: e, dy: t });
}, ct = (e) => {
  const { container: t, map: n, nodes: o } = e, s = n.querySelector("me-root"), i = s.offsetTop, l = s.offsetLeft, r = s.offsetWidth, c = s.offsetHeight;
  let a, h;
  return e.alignment === "root" ? (a = t.offsetWidth / 2 - l - r / 2, h = t.offsetHeight / 2 - i - c / 2, n.style.transformOrigin = `${l + r / 2}px 50%`) : (a = (t.offsetWidth - o.offsetWidth) / 2, h = (t.offsetHeight - o.offsetHeight) / 2, n.style.transformOrigin = "50% 50%"), { dx: a, dy: h };
}, Hn = function() {
  const { map: e, container: t } = this, { dx: n, dy: o } = ct(this);
  t.scrollTop = 0, t.scrollLeft = 0, e.style.transform = `translate(${n}px, ${o}px) scale(${this.scaleVal})`;
}, Bn = function(e) {
  e(this);
}, Rn = function(e) {
  e.nodeObj.parent && (this.clearSelection(), this.tempDirection === null && (this.tempDirection = this.direction), this.isFocusMode || (this.nodeDataBackup = this.nodeData, this.isFocusMode = !0), this.nodeData = e.nodeObj, this.initRight(), this.toCenter());
}, In = function() {
  this.isFocusMode = !1, this.tempDirection !== null && (this.nodeData = this.nodeDataBackup, this.direction = this.tempDirection, this.tempDirection = null, this.refresh(), this.toCenter());
}, Fn = function() {
  this.direction = 0, this.refresh(), this.toCenter(), this.bus.fire("changeDirection", this.direction);
}, Wn = function() {
  this.direction = 1, this.refresh(), this.toCenter(), this.bus.fire("changeDirection", this.direction);
}, Kn = function() {
  this.direction = 2, this.refresh(), this.toCenter(), this.bus.fire("changeDirection", this.direction);
}, Gn = function(e) {
  this.locale = e, this.refresh();
}, Yn = function(e, t) {
  const n = e.nodeObj;
  typeof t == "boolean" ? n.expanded = t : n.expanded !== !1 ? n.expanded = !1 : n.expanded = !0;
  const o = e.getBoundingClientRect(), s = {
    x: o.left,
    y: o.top
  }, i = e.parentNode, l = i.children[1];
  if (l.expanded = n.expanded, l.className = n.expanded ? "minus" : "", J(e), n.expanded) {
    const u = this.createChildren(
      n.children.map((g) => this.createWrapper(g).grp)
    );
    i.parentNode.appendChild(u);
  } else
    i.parentNode.children[1].remove();
  this.linkDiv(e.closest("me-main > me-wrapper"));
  const r = e.getBoundingClientRect(), c = {
    x: r.left,
    y: r.top
  }, a = s.x - c.x, h = s.y - c.y;
  this.move(a, h), this.bus.fire("expandNode", n);
}, zn = function(e, t) {
  const n = e.nodeObj, o = e.getBoundingClientRect(), s = {
    x: o.left,
    y: o.top
  };
  z(n, t ?? !n.expanded), this.refresh();
  const i = this.findEle(n.id).getBoundingClientRect(), l = {
    x: i.left,
    y: i.top
  }, r = s.x - l.x, c = s.y - l.y;
  this.move(r, c);
}, qn = function(e) {
  this.clearSelection(), e && (e = JSON.parse(JSON.stringify(e)), this.nodeData = e.nodeData, this.arrows = e.arrows || [], this.summaries = e.summaries || [], e.theme && this.changeTheme(e.theme)), R(this.nodeData), this.layout(), this.linkDiv();
}, Vn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cancelFocus: In,
  clearSelection: Ln,
  disableEdit: Pn,
  enableEdit: Dn,
  expandNode: Yn,
  expandNodeAll: zn,
  focusNode: Rn,
  getData: Mn,
  getDataString: An,
  initLeft: Fn,
  initRight: Wn,
  initSide: Kn,
  install: Bn,
  move: jn,
  refresh: qn,
  scale: $n,
  scaleFit: On,
  scrollIntoView: Nn,
  selectNode: kn,
  selectNodes: _n,
  setLocale: Gn,
  toCenter: Hn,
  unselectNodes: Tn
}, Symbol.toStringTag, { value: "Module" })), Xn = function(e) {
  return {
    dom: e,
    moved: !1,
    // differentiate click and move
    pointerdown: !1,
    lastX: 0,
    lastY: 0,
    handlePointerMove(t) {
      if (this.pointerdown) {
        this.moved = !0;
        const n = t.clientX - this.lastX, o = t.clientY - this.lastY;
        this.lastX = t.clientX, this.lastY = t.clientY, this.cb && this.cb(n, o);
      }
    },
    handlePointerDown(t) {
      t.button === 0 && (this.pointerdown = !0, this.lastX = t.clientX, this.lastY = t.clientY, this.dom.setPointerCapture(t.pointerId));
    },
    handleClear(t) {
      this.pointerdown = !1, t.pointerId !== void 0 && this.dom.releasePointerCapture(t.pointerId);
    },
    cb: null,
    init(t, n) {
      this.cb = n, this.handleClear = this.handleClear.bind(this), this.handlePointerMove = this.handlePointerMove.bind(this), this.handlePointerDown = this.handlePointerDown.bind(this), this.destroy = Ce([
        { dom: t, evt: "pointermove", func: this.handlePointerMove },
        { dom: t, evt: "pointerleave", func: this.handleClear },
        { dom: t, evt: "pointerup", func: this.handleClear },
        { dom: this.dom, evt: "pointerdown", func: this.handlePointerDown }
      ]);
    },
    destroy: null,
    clear() {
      this.moved = !1, this.pointerdown = !1;
    }
  };
}, Ye = {
  create: Xn
}, Un = "#4dc4ff";
function at(e, t, n, o, s, i, l, r) {
  return {
    x: e / 8 + n * 3 / 8 + s * 3 / 8 + l / 8,
    y: t / 8 + o * 3 / 8 + i * 3 / 8 + r / 8
  };
}
function Jn(e, t, n) {
  e && (e.dataset.x = t.toString(), e.dataset.y = n.toString(), de(e));
}
function te(e, t, n, o, s) {
  k(e, {
    x1: t + "",
    y1: n + "",
    x2: o + "",
    y2: s + ""
  });
}
function ze(e, t, n, o, s, i, l, r, c, a) {
  const h = `M ${t} ${n} C ${o} ${s} ${i} ${l} ${r} ${c}`;
  if (e.line.setAttribute("d", h), a.style) {
    const p = a.style;
    p.stroke && e.line.setAttribute("stroke", p.stroke), p.strokeWidth && e.line.setAttribute("stroke-width", String(p.strokeWidth)), p.strokeDasharray && e.line.setAttribute("stroke-dasharray", p.strokeDasharray), p.strokeLinecap && e.line.setAttribute("stroke-linecap", p.strokeLinecap), p.opacity !== void 0 && e.line.setAttribute("opacity", String(p.opacity));
  }
  const u = e.querySelectorAll('path[stroke="transparent"]');
  u.length > 0 && u[0].setAttribute("d", h);
  const g = ie(i, l, r, c);
  if (g) {
    const p = `M ${g.x1} ${g.y1} L ${r} ${c} L ${g.x2} ${g.y2}`;
    if (e.arrow1.setAttribute("d", p), u.length > 1 && u[1].setAttribute("d", p), a.style) {
      const d = a.style;
      d.stroke && e.arrow1.setAttribute("stroke", d.stroke), d.strokeWidth && e.arrow1.setAttribute("stroke-width", String(d.strokeWidth)), d.strokeLinecap && e.arrow1.setAttribute("stroke-linecap", d.strokeLinecap), d.opacity !== void 0 && e.arrow1.setAttribute("opacity", String(d.opacity));
    }
  }
  if (a.bidirectional) {
    const p = ie(o, s, t, n);
    if (p) {
      const d = `M ${p.x1} ${p.y1} L ${t} ${n} L ${p.x2} ${p.y2}`;
      if (e.arrow2.setAttribute("d", d), u.length > 2 && u[2].setAttribute("d", d), a.style) {
        const f = a.style;
        f.stroke && e.arrow2.setAttribute("stroke", f.stroke), f.strokeWidth && e.arrow2.setAttribute("stroke-width", String(f.strokeWidth)), f.strokeLinecap && e.arrow2.setAttribute("stroke-linecap", f.strokeLinecap), f.opacity !== void 0 && e.arrow2.setAttribute("opacity", String(f.opacity));
      }
    }
  }
  const { x: v, y: m } = at(t, n, o, s, i, l, r, c);
  if (e.labelEl && Jn(e.labelEl, v, m), a.style?.labelColor) {
    const p = e.labelEl;
    p && (p.style.color = a.style.labelColor);
  }
  io(e);
}
function ce(e, t, n) {
  const { offsetLeft: o, offsetTop: s } = $(e.nodes, t), i = t.offsetWidth, l = t.offsetHeight, r = o + i / 2, c = s + l / 2, a = r + n.x, h = c + n.y;
  return {
    w: i,
    h: l,
    cx: r,
    cy: c,
    ctrlX: a,
    ctrlY: h
  };
}
function Y(e) {
  let t, n;
  const o = (e.cy - e.ctrlY) / (e.ctrlX - e.cx);
  return o > e.h / e.w || o < -e.h / e.w ? e.cy - e.ctrlY < 0 ? (t = e.cx - e.h / 2 / o, n = e.cy + e.h / 2) : (t = e.cx + e.h / 2 / o, n = e.cy - e.h / 2) : e.cx - e.ctrlX < 0 ? (t = e.cx + e.w / 2, n = e.cy - e.w * o / 2) : (t = e.cx - e.w / 2, n = e.cy + e.w * o / 2), {
    x: t,
    y: n
  };
}
const _e = function(e, t, n, o, s) {
  if (!t || !n)
    return;
  const i = ce(e, t, o.delta1), l = ce(e, n, o.delta2), { x: r, y: c } = Y(i), { ctrlX: a, ctrlY: h } = i, { ctrlX: u, ctrlY: g } = l, { x: v, y: m } = Y(l), p = ie(u, g, v, m);
  if (!p) return;
  const d = `M ${p.x1} ${p.y1} L ${v} ${m} L ${p.x2} ${p.y2}`;
  let f = "";
  if (o.bidirectional) {
    const N = ie(a, h, r, c);
    if (!N) return;
    f = `M ${N.x1} ${N.y1} L ${r} ${c} L ${N.x2} ${N.y2}`;
  }
  const y = Lt(`M ${r} ${c} C ${a} ${h} ${u} ${g} ${v} ${m}`, d, f, o.style), { x: w, y: S } = at(r, c, a, h, u, g, v, m), E = o.style?.labelColor || "rgb(235, 95, 82)", x = "arrow-" + o.id;
  y.id = x;
  const b = e.markdown ? e.markdown(o.label, o) : o.label, C = ge(b, w, S, {
    anchor: "middle",
    color: E,
    dataType: "arrow",
    svgId: x
  });
  y.labelEl = C, y.arrowObj = o, y.dataset.linkid = o.id, e.labelContainer.appendChild(C), e.linkSvgGroup.appendChild(y), de(C), s || (e.arrows.push(o), e.currentArrow = y, dt(e, o, i, l));
}, Zn = function(e, t, n = {}) {
  const o = {
    id: W(),
    label: "Custom Link",
    from: e.nodeObj.id,
    to: t.nodeObj.id,
    delta1: {
      x: e.offsetWidth / 2 + 100,
      y: 0
    },
    delta2: {
      x: t.offsetWidth / 2 + 100,
      y: 0
    },
    ...n
  };
  _e(this, e, t, o), this.bus.fire("operation", {
    name: "createArrow",
    obj: o
  });
}, Qn = function(e) {
  he(this);
  const t = { ...e, id: W() };
  _e(this, this.findEle(t.from), this.findEle(t.to), t), this.bus.fire("operation", {
    name: "createArrow",
    obj: t
  });
}, eo = function(e) {
  let t;
  if (e ? t = e : t = this.currentArrow, !t) return;
  he(this);
  const n = t.arrowObj.id;
  this.arrows = this.arrows.filter((o) => o.id !== n), t.remove(), this.bus.fire("operation", {
    name: "removeArrow",
    obj: {
      id: n
    }
  });
}, to = function(e) {
  this.currentArrow = e;
  const t = e.arrowObj, n = this.findEle(t.from), o = this.findEle(t.to), s = ce(this, n, t.delta1), i = ce(this, o, t.delta2);
  dt(this, t, s, i);
}, no = function() {
  he(this), this.currentArrow = null;
}, fe = function(e, t) {
  const n = document.createElementNS(M, "path");
  return k(n, {
    d: e,
    stroke: t,
    fill: "none",
    "stroke-width": "6",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }), n;
}, oo = function(e, t) {
  const n = document.createElementNS(M, "g");
  n.setAttribute("class", "arrow-highlight"), n.setAttribute("opacity", "0.45");
  const o = fe(e.line.getAttribute("d"), t);
  n.appendChild(o);
  const s = fe(e.arrow1.getAttribute("d"), t);
  if (n.appendChild(s), e.arrow2.getAttribute("d")) {
    const i = fe(e.arrow2.getAttribute("d"), t);
    n.appendChild(i);
  }
  e.insertBefore(n, e.firstChild);
}, so = function(e) {
  const t = e.querySelector(".arrow-highlight");
  t && t.remove();
}, io = function(e) {
  const t = e.querySelector(".arrow-highlight");
  if (!t) return;
  const n = t.querySelectorAll("path");
  n.length >= 1 && n[0].setAttribute("d", e.line.getAttribute("d")), n.length >= 2 && n[1].setAttribute("d", e.arrow1.getAttribute("d")), n.length >= 3 && e.arrow2.getAttribute("d") && n[2].setAttribute("d", e.arrow2.getAttribute("d"));
}, he = function(e) {
  e.helper1?.destroy(), e.helper2?.destroy(), e.linkController.style.display = "none", e.P2.style.display = "none", e.P3.style.display = "none", e.currentArrow && so(e.currentArrow);
}, dt = function(e, t, n, o) {
  const { linkController: s, P2: i, P3: l, line1: r, line2: c, nodes: a, map: h, currentArrow: u, bus: g } = e;
  if (!u) return;
  s.style.display = "initial", i.style.display = "initial", l.style.display = "initial", a.appendChild(s), a.appendChild(i), a.appendChild(l), oo(u, Un);
  let { x: v, y: m } = Y(n), { ctrlX: p, ctrlY: d } = n, { ctrlX: f, ctrlY: y } = o, { x: w, y: S } = Y(o);
  i.style.cssText = `top:${d}px;left:${p}px;`, l.style.cssText = `top:${y}px;left:${f}px;`, te(r, v, m, p, d), te(c, f, y, w, S), e.helper1 = Ye.create(i), e.helper2 = Ye.create(l), e.helper1.init(h, (E, x) => {
    p = p + E / e.scaleVal, d = d + x / e.scaleVal;
    const b = Y({ ...n, ctrlX: p, ctrlY: d });
    v = b.x, m = b.y, i.style.top = d + "px", i.style.left = p + "px", ze(u, v, m, p, d, f, y, w, S, t), te(r, v, m, p, d), t.delta1.x = p - n.cx, t.delta1.y = d - n.cy, g.fire("updateArrowDelta", t);
  }), e.helper2.init(h, (E, x) => {
    f = f + E / e.scaleVal, y = y + x / e.scaleVal;
    const b = Y({ ...o, ctrlX: f, ctrlY: y });
    w = b.x, S = b.y, l.style.top = y + "px", l.style.left = f + "px", ze(u, v, m, p, d, f, y, w, S, t), te(c, f, y, w, S), t.delta2.x = f - o.cx, t.delta2.y = y - o.cy, g.fire("updateArrowDelta", t);
  });
};
function ro() {
  this.linkSvgGroup.innerHTML = "";
  for (let e = 0; e < this.arrows.length; e++) {
    const t = this.arrows[e];
    try {
      _e(this, this.findEle(t.from), this.findEle(t.to), t, !0);
    } catch {
    }
  }
  this.nodes.appendChild(this.linkSvgGroup);
}
function lo(e) {
  he(this), e && e.labelEl && Qe(this, e.labelEl, e.arrowObj);
}
function co() {
  this.arrows = this.arrows.filter((e) => se(e.from, this.nodeData) && se(e.to, this.nodeData));
}
const ao = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createArrow: Zn,
  createArrowFrom: Qn,
  editArrowLabel: lo,
  removeArrow: eo,
  renderArrow: ro,
  selectArrow: to,
  tidyArrow: co,
  unselectArrow: no
}, Symbol.toStringTag, { value: "Module" })), ho = function(e) {
  if (e.length === 0) throw new Error("No selected node.");
  if (e.length === 1) {
    const c = e[0].nodeObj, a = e[0].nodeObj.parent;
    if (!a) throw new Error("Can not select root node.");
    const h = a.children.findIndex((u) => c === u);
    return {
      parent: a.id,
      start: h,
      end: h
    };
  }
  let t = 0;
  const n = e.map((c) => {
    let a = c.nodeObj;
    const h = [];
    for (; a.parent; ) {
      const u = a.parent, v = u.children?.indexOf(a);
      a = u, h.unshift({ node: a, index: v });
    }
    return h.length > t && (t = h.length), h;
  });
  let o = 0;
  e: for (; o < t; o++) {
    const c = n[0][o]?.node;
    for (let a = 1; a < n.length; a++)
      if (n[a][o]?.node !== c)
        break e;
  }
  if (!o) throw new Error("Can not select root node.");
  const s = n.map((c) => c[o - 1].index).sort(), i = s[0] || 0, l = s[s.length - 1] || 0, r = n[0][o - 1].node;
  if (!r.parent) throw new Error("Please select nodes in the same main topic.");
  return {
    parent: r.id,
    start: i,
    end: l
  };
}, fo = function(e) {
  const t = document.createElementNS(M, "g");
  return t.setAttribute("id", e), t;
}, qe = function(e, t) {
  const n = document.createElementNS(M, "path");
  return k(n, {
    d: e,
    stroke: t || "#666",
    fill: "none",
    "stroke-linecap": "round",
    "stroke-width": "2"
  }), n;
}, uo = (e) => e.parentElement.parentElement, po = function(e, { parent: t, start: n }) {
  const o = e.findEle(t), s = o.nodeObj;
  let i;
  return s.parent ? i = o.closest("me-main").className : i = e.findEle(s.children[n].id).closest("me-main").className, i;
}, Te = function(e, t) {
  const { id: n, label: o, parent: s, start: i, end: l, style: r } = t, { nodes: c, theme: a, summarySvg: h } = e, g = e.findEle(s).nodeObj, v = po(e, t);
  let m = 1 / 0, p = 0, d = 0, f = 0;
  for (let X = i; X <= l; X++) {
    const Le = g.children?.[X];
    if (!Le)
      return e.removeSummary(n), null;
    const Z = uo(e.findEle(Le.id)), { offsetLeft: Q, offsetTop: Ae } = $(c, Z), Me = i === l ? 10 : 20;
    X === i && (d = Ae + Me), X === l && (f = Ae + Z.offsetHeight - Me), Q < m && (m = Q), Z.offsetWidth + Q > p && (p = Z.offsetWidth + Q);
  }
  let y, w;
  const S = g.parent ? 10 : 0, E = d + S, x = f + S, b = (E + x) / 2, C = r?.stroke || a.cssVar["--color"], N = r?.labelColor || a.cssVar["--color"], L = "s-" + n, O = e.markdown ? e.markdown(o, t) : o;
  v === D.LHS ? (y = qe(`M ${m + 10} ${E} c -5 0 -10 5 -10 10 L ${m} ${x - 10} c 0 5 5 10 10 10 M ${m} ${b} h -10`, C), w = ge(O, m - 20, b, { anchor: "end", color: N, dataType: "summary", svgId: L })) : (y = qe(`M ${p - 10} ${E} c 5 0 10 5 10 10 L ${p} ${x - 10} c 0 5 -5 10 -10 10 M ${p} ${b} h 10`, C), w = ge(O, p + 20, b, { anchor: "start", color: N, dataType: "summary", svgId: L }));
  const j = fo(L);
  return j.appendChild(y), e.labelContainer.appendChild(w), de(w), j.summaryObj = t, j.labelEl = w, h.appendChild(j), j;
}, go = function(e = {}) {
  if (!this.currentNodes) return;
  const { currentNodes: t, summaries: n, bus: o } = this, { parent: s, start: i, end: l } = ho(t), r = { id: W(), parent: s, start: i, end: l, label: "summary", style: e.style }, c = Te(this, r);
  n.push(r), this.editSummary(c), o.fire("operation", {
    name: "createSummary",
    obj: r
  });
}, mo = function(e) {
  const t = W(), n = { ...e, id: t };
  Te(this, n), this.summaries.push(n), this.bus.fire("operation", {
    name: "createSummary",
    obj: n
  });
}, yo = function(e) {
  const t = this.summaries.findIndex((n) => n.id === e);
  t > -1 && (this.summaries.splice(t, 1), this.nodes.querySelector("#s-" + e)?.remove(), this.nodes.querySelector("#label-s-" + e)?.remove()), this.bus.fire("operation", {
    name: "removeSummary",
    obj: { id: e }
  });
}, vo = function(e) {
  const t = e.labelEl;
  t && t.classList.add("selected"), this.currentSummary = e;
}, bo = function() {
  this.currentSummary?.labelEl?.classList.remove("selected"), this.currentSummary = null;
}, wo = function() {
  this.summarySvg.innerHTML = "", this.summaries.forEach((e) => {
    try {
      Te(this, e);
    } catch {
    }
  }), this.nodes.insertAdjacentElement("beforeend", this.summarySvg);
}, xo = function(e) {
  e && e.labelEl && Qe(this, e.labelEl, e.summaryObj);
}, Eo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createSummary: go,
  createSummaryFrom: mo,
  editSummary: xo,
  removeSummary: yo,
  renderSummary: wo,
  selectSummary: vo,
  unselectSummary: bo
}, Symbol.toStringTag, { value: "Module" })), T = "http://www.w3.org/2000/svg";
function Co(e, t) {
  const n = document.createElementNS(T, "svg");
  return k(n, {
    version: "1.1",
    xmlns: T,
    height: e,
    width: t
  }), n;
}
function So(e, t) {
  return (parseInt(e) - parseInt(t)) / 2;
}
function No(e, t, n, o) {
  const s = document.createElementNS(T, "g");
  let i = "";
  return e.text ? i = e.text.textContent : i = e.childNodes[0].textContent, i.split(`
`).forEach((r, c) => {
    const a = document.createElementNS(T, "text");
    k(a, {
      x: n + parseInt(t.paddingLeft) + "",
      y: o + parseInt(t.paddingTop) + So(t.lineHeight, t.fontSize) * (c + 1) + parseFloat(t.fontSize) * (c + 1) + "",
      "text-anchor": "start",
      "font-family": t.fontFamily,
      "font-size": `${t.fontSize}`,
      "font-weight": `${t.fontWeight}`,
      fill: `${t.color}`
    }), a.innerHTML = r, s.appendChild(a);
  }), s;
}
function ko(e, t, n, o) {
  let s = "";
  e.nodeObj?.dangerouslySetInnerHTML ? s = e.nodeObj.dangerouslySetInnerHTML : e.text ? s = e.text.textContent : s = e.childNodes[0].textContent;
  const i = document.createElementNS(T, "foreignObject");
  k(i, {
    x: n + parseInt(t.paddingLeft) + "",
    y: o + parseInt(t.paddingTop) + "",
    width: t.width,
    height: t.height
  });
  const l = document.createElement("div");
  return k(l, {
    xmlns: "http://www.w3.org/1999/xhtml",
    style: `font-family: ${t.fontFamily}; font-size: ${t.fontSize}; font-weight: ${t.fontWeight}; color: ${t.color}; white-space: pre-wrap;`
  }), l.innerHTML = s, i.appendChild(l), i;
}
function _o(e, t) {
  const n = getComputedStyle(t), { offsetLeft: o, offsetTop: s } = $(e.nodes, t), i = document.createElementNS(T, "rect");
  return k(i, {
    x: o + "",
    y: s + "",
    rx: n.borderRadius,
    ry: n.borderRadius,
    width: n.width,
    height: n.height,
    fill: n.backgroundColor,
    stroke: n.borderColor,
    "stroke-width": n.borderWidth
  }), i;
}
function ne(e, t, n = !1) {
  const o = getComputedStyle(t), { offsetLeft: s, offsetTop: i } = $(e.nodes, t), l = document.createElementNS(T, "rect");
  k(l, {
    x: s + "",
    y: i + "",
    rx: o.borderRadius,
    ry: o.borderRadius,
    width: o.width,
    height: o.height,
    fill: o.backgroundColor,
    stroke: o.borderColor,
    "stroke-width": o.borderWidth
  });
  const r = document.createElementNS(T, "g");
  r.appendChild(l);
  let c;
  return n ? c = ko(t, o, s, i) : c = No(t, o, s, i), r.appendChild(c), r;
}
function To(e, t) {
  const n = getComputedStyle(t), { offsetLeft: o, offsetTop: s } = $(e.nodes, t), i = document.createElementNS(T, "a"), l = document.createElementNS(T, "text");
  return k(l, {
    x: o + "",
    y: s + parseInt(n.fontSize) + "",
    "text-anchor": "start",
    "font-family": n.fontFamily,
    "font-size": `${n.fontSize}`,
    "font-weight": `${n.fontWeight}`,
    fill: `${n.color}`
  }), l.innerHTML = t.textContent, i.appendChild(l), i.setAttribute("href", t.href), i;
}
function Lo(e, t) {
  const n = getComputedStyle(t), { offsetLeft: o, offsetTop: s } = $(e.nodes, t), i = document.createElementNS(T, "image");
  return k(i, {
    x: o + "",
    y: s + "",
    width: n.width + "",
    height: n.height + "",
    href: t.src
  }), i;
}
const oe = 100, Ao = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">', Mo = (e, t = !1) => {
  const n = e.nodes, o = n.offsetHeight + oe * 2, s = n.offsetWidth + oe * 2, i = Co(o + "px", s + "px"), l = document.createElementNS(T, "svg"), r = document.createElementNS(T, "rect");
  k(r, {
    x: "0",
    y: "0",
    width: `${s}`,
    height: `${o}`,
    fill: e.theme.cssVar["--bgcolor"]
  }), i.appendChild(r), n.querySelectorAll(".subLines").forEach((u) => {
    const g = u.cloneNode(!0), { offsetLeft: v, offsetTop: m } = $(n, u.parentElement);
    g.setAttribute("x", `${v}`), g.setAttribute("y", `${m}`), l.appendChild(g);
  });
  const c = n.querySelector(".lines")?.cloneNode(!0);
  c && l.appendChild(c);
  const a = n.querySelector(".topiclinks")?.cloneNode(!0);
  a && l.appendChild(a);
  const h = n.querySelector(".summary")?.cloneNode(!0);
  return h && l.appendChild(h), n.querySelectorAll("me-tpc").forEach((u) => {
    u.nodeObj.dangerouslySetInnerHTML ? l.appendChild(ne(e, u, !t)) : (l.appendChild(_o(e, u)), l.appendChild(ne(e, u.text, !t)));
  }), n.querySelectorAll(".tags > span").forEach((u) => {
    l.appendChild(ne(e, u));
  }), n.querySelectorAll(".icons > span").forEach((u) => {
    l.appendChild(ne(e, u));
  }), n.querySelectorAll(".hyper-link").forEach((u) => {
    l.appendChild(To(e, u));
  }), n.querySelectorAll("img").forEach((u) => {
    l.appendChild(Lo(e, u));
  }), k(l, {
    x: oe + "",
    y: oe + "",
    overflow: "visible"
  }), i.appendChild(l), i;
}, Do = (e, t) => (t && e.insertAdjacentHTML("afterbegin", "<style>" + t + "</style>"), Ao + e.outerHTML);
function Po(e) {
  return new Promise((t, n) => {
    const o = new FileReader();
    o.onload = (s) => {
      t(s.target.result);
    }, o.onerror = (s) => {
      n(s);
    }, o.readAsDataURL(e);
  });
}
const $o = function(e = !1, t) {
  const n = Mo(this, e), o = Do(n, t);
  return new Blob([o], { type: "image/svg+xml" });
}, Oo = async function(e = !1, t) {
  const n = this.exportSvg(e, t), o = await Po(n);
  return new Promise((s, i) => {
    const l = new Image();
    l.setAttribute("crossOrigin", "anonymous"), l.onload = () => {
      const r = document.createElement("canvas");
      r.width = l.width, r.height = l.height, r.getContext("2d").drawImage(l, 0, 0), r.toBlob(s, "image/png", 1);
    }, l.src = o, l.onerror = i;
  });
}, jo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  exportPng: Oo,
  exportSvg: $o
}, Symbol.toStringTag, { value: "Module" }));
function Ho(e, t) {
  return async function(...n) {
    const o = this.before[t];
    o && !await o.apply(this, n) || e.apply(this, n);
  };
}
const Ve = Object.keys(lt), ht = {};
for (let e = 0; e < Ve.length; e++) {
  const t = Ve[e];
  ht[t] = Ho(lt[t], t);
}
const Bo = {
  getObjById: se,
  generateNewObj: ft,
  layout: xt,
  linkDiv: At,
  editTopic: Tt,
  createWrapper: St,
  createParent: Nt,
  createChildren: kt,
  createTopic: _t,
  findEle: Ue,
  changeTheme: nn,
  ...Vn,
  ...ht,
  ...ao,
  ...Eo,
  ...jo,
  init(e) {
    if (e = JSON.parse(JSON.stringify(e)), !e || !e.nodeData) return new Error("MindElixir: `data` is required");
    e.direction !== void 0 && (this.direction = e.direction), this.changeTheme(e.theme || this.theme, !1), this.nodeData = e.nodeData, R(this.nodeData), this.arrows = e.arrows || [], this.summaries = e.summaries || [], this.tidyArrow(), this.toolBar && Vt(this), this.keypress && vt(this, this.keypress), this.editable && tn(this), this.contextMenu && this.disposable.push(Mt(this, this.contextMenu)), this.draggable && this.disposable.push(Ot(this)), this.allowUndo && this.disposable.push(Ht(this)), this.layout(), this.linkDiv(), this.toCenter();
  },
  destroy() {
    this.disposable.forEach((e) => e()), this.el && (this.el.innerHTML = ""), this.el = void 0, this.nodeData = void 0, this.arrows = void 0, this.summaries = void 0, this.currentArrow = void 0, this.currentNodes = void 0, this.currentSummary = void 0, this.waitCopy = void 0, this.theme = void 0, this.direction = void 0, this.bus = void 0, this.container = void 0, this.map = void 0, this.lines = void 0, this.linkController = void 0, this.linkSvgGroup = void 0, this.P2 = void 0, this.P3 = void 0, this.line1 = void 0, this.line2 = void 0, this.nodes = void 0, this.selection?.destroy(), this.selection = void 0;
  }
};
function Ro({ pT: e, pL: t, pW: n, pH: o, cT: s, cL: i, cW: l, cH: r, direction: c, containerHeight: a }) {
  let h = t + n / 2;
  const u = e + o / 2;
  let g;
  c === D.LHS ? g = i + l : g = i;
  const v = s + r / 2, p = (1 - Math.abs(v - u) / a) * 0.25 * (n / 2);
  return c === D.LHS ? h = h - n / 10 - p : h = h + n / 10 + p, `M ${h} ${u} Q ${h} ${v} ${g} ${v}`;
}
function Io({ pT: e, pL: t, pW: n, pH: o, cT: s, cL: i, cW: l, cH: r, direction: c, isFirst: a }) {
  const h = parseInt(this.container.style.getPropertyValue("--node-gap-x"));
  let u = 0, g = 0;
  a ? u = e + o / 2 : u = e + o;
  const v = s + r;
  let m = 0, p = 0, d = 0;
  const f = Math.abs(u - v) / 300 * h;
  return c === D.LHS ? (d = t, m = d + h, p = d - h, g = i + h, `M ${m} ${u} C ${d} ${u} ${d + f} ${v} ${p} ${v} H ${g}`) : (d = t + n, m = d - h, p = d + h, g = i + l - h, `M ${m} ${u} C ${d} ${u} ${d - f} ${v} ${p} ${v} H ${g}`);
}
const Fo = "5.3.4";
function Wo(e) {
  return {
    x: 0,
    y: 0,
    moved: !1,
    // diffrentiate click and move
    mousedown: !1,
    onMove(t, n) {
      this.mousedown && (this.moved = !0, e.move(t, n));
    },
    clear() {
      this.mousedown = !1;
    }
  };
}
const G = document;
function MindElixir({
  el: e,
  direction: t,
  locale: n,
  draggable: o,
  editable: s,
  contextMenu: i,
  toolBar: l,
  keypress: r,
  mouseSelectionButton: c,
  selectionContainer: a,
  before: h,
  newTopicName: u,
  allowUndo: g,
  generateMainBranch: v,
  generateSubBranch: m,
  overflowHidden: p,
  theme: d,
  alignment: f,
  scaleSensitivity: y,
  scaleMax: w,
  scaleMin: S,
  handleWheel: E,
  markdown: x,
  imageProxy: b
}) {
  let C = null;
  const N = Object.prototype.toString.call(e);
  if (N === "[object HTMLDivElement]" ? C = e : N === "[object String]" && (C = document.querySelector(e)), !C) throw new Error("MindElixir: el is not a valid element");
  C.style.position = "relative", C.innerHTML = "", this.el = C, this.disposable = [], this.before = h || {}, this.locale = n || "en", this.newTopicName = u || "New Node", this.contextMenu = i ?? !0, this.toolBar = l ?? !0, this.keypress = r ?? !0, this.mouseSelectionButton = c ?? 0, this.direction = t ?? 1, this.draggable = o ?? !0, this.editable = s ?? !0, this.allowUndo = g ?? !0, this.scaleSensitivity = y ?? 0.1, this.scaleMax = w ?? 1.4, this.scaleMin = S ?? 0.2, this.generateMainBranch = v || Ro, this.generateSubBranch = m || Io, this.overflowHidden = p ?? !1, this.alignment = f ?? "root", this.handleWheel = E ?? !0, this.markdown = x || void 0, this.imageProxy = b || void 0, this.currentNodes = [], this.currentArrow = null, this.scaleVal = 1, this.tempDirection = null, this.dragMoveHelper = Wo(this), this.bus = wt(), this.container = G.createElement("div"), this.selectionContainer = a || this.container, this.container.className = "map-container";
  const L = window.matchMedia("(prefers-color-scheme: dark)");
  this.theme = d || (L.matches ? we : be);
  const O = G.createElement("div");
  O.className = "map-canvas", this.map = O, this.container.setAttribute("tabindex", "0"), this.container.appendChild(this.map), this.el.appendChild(this.container), this.nodes = G.createElement("me-nodes"), this.lines = U("lines"), this.summarySvg = U("summary"), this.linkController = U("linkcontroller"), this.P2 = G.createElement("div"), this.P3 = G.createElement("div"), this.P2.className = this.P3.className = "circle", this.P2.style.display = this.P3.style.display = "none", this.line1 = $e(), this.line2 = $e(), this.linkController.appendChild(this.line1), this.linkController.appendChild(this.line2), this.linkSvgGroup = U("topiclinks"), this.labelContainer = G.createElement("div"), this.labelContainer.className = "label-container", this.map.appendChild(this.nodes), this.overflowHidden ? this.container.style.overflow = "hidden" : this.disposable.push(bt(this));
}
MindElixir.prototype = Bo;
Object.defineProperty(MindElixir.prototype, "currentNode", {
  get() {
    return this.currentNodes[this.currentNodes.length - 1];
  },
  enumerable: !0
});
MindElixir.LEFT = 0;
MindElixir.RIGHT = 1;
MindElixir.SIDE = 2;
MindElixir.THEME = be;
MindElixir.DARK_THEME = we;
MindElixir.version = Fo;
MindElixir.E = Ue;
MindElixir.new = (e) => ({
  nodeData: {
    id: W(),
    topic: e || "new topic",
    children: []
  }
});
  </script>
  <script>
    let base_url = 'http://127.0.0.1:8081';
    let mind;

    // record the current mindmap status 
    function update_mindmap() {
      let uuid = document.getElementById('select-mindmap').value;
      let label = document.getElementById('input-label').value;
      fetch(base_url+'/update?uuid='+uuid+'&label='+label, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain;charset=UTF-8',
        },
        body: mind.getDataString(),
      }).catch(error => {{
        console.error('Failed update mindmap:', error);
      }});
    }
    document.getElementById('update').addEventListener('click', function(event) {
      update_mindmap();
    })

    // select mindmap
    document.getElementById('select-mindmap').addEventListener('change', function(event) {
      let uuid = document.getElementById('select-mindmap').value;
      window.location.href = base_url+'/previous?uuid='+uuid;
    })

    // new mindmap
    document.getElementById('new').addEventListener('click', function(event) {
      window.location.href = base_url;
    })

    // save as png
    const style = ``;
    const katex = ``;
    const download = () => {
      return () => {
        let blob = null
        mind.exportPng(false, style + katex)
          .then(blob => {
            if (!blob) return;
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap.png';
            a.click();
            URL.revokeObjectURL(url);
          })
          .catch(e => {
            console.error(e);
          });
      }
    }
    document.getElementById('save-image').addEventListener('click', function(event) {
      download()();
    })

    mind = new MindElixir({
      el: '#map',
      direction: MindElixir.RIGHT,
      draggable: true, // default true
      contextMenu: true, // default true
      toolBar: true, // default true
      nodeMenu: true, // default true
      keypress: true, // default true
      allowUndo: true,
      locale: 'en', // zh_CN,zh_TW,en,ja,pt,ru
    })
    const data = MindElixir.new('root')
    mind.init(data)
  </script>
</html>